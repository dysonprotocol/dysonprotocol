// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dysonprotocol/nameservice/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	types1 "github.com/cosmos/cosmos-sdk/x/bank/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgCommit struct {
	Committer string     `protobuf:"bytes,1,opt,name=committer,proto3" json:"committer,omitempty"`
	Hexhash   string     `protobuf:"bytes,2,opt,name=hexhash,proto3" json:"hexhash,omitempty"`
	Valuation types.Coin `protobuf:"bytes,3,opt,name=valuation,proto3" json:"valuation"`
}

func (m *MsgCommit) Reset()         { *m = MsgCommit{} }
func (m *MsgCommit) String() string { return proto.CompactTextString(m) }
func (*MsgCommit) ProtoMessage()    {}
func (*MsgCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{0}
}
func (m *MsgCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommit.Merge(m, src)
}
func (m *MsgCommit) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommit proto.InternalMessageInfo

func (m *MsgCommit) GetCommitter() string {
	if m != nil {
		return m.Committer
	}
	return ""
}

func (m *MsgCommit) GetHexhash() string {
	if m != nil {
		return m.Hexhash
	}
	return ""
}

func (m *MsgCommit) GetValuation() types.Coin {
	if m != nil {
		return m.Valuation
	}
	return types.Coin{}
}

type MsgCommitResponse struct {
}

func (m *MsgCommitResponse) Reset()         { *m = MsgCommitResponse{} }
func (m *MsgCommitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCommitResponse) ProtoMessage()    {}
func (*MsgCommitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{1}
}
func (m *MsgCommitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitResponse.Merge(m, src)
}
func (m *MsgCommitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitResponse proto.InternalMessageInfo

type MsgReveal struct {
	Committer string `protobuf:"bytes,1,opt,name=committer,proto3" json:"committer,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Salt      string `protobuf:"bytes,3,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *MsgReveal) Reset()         { *m = MsgReveal{} }
func (m *MsgReveal) String() string { return proto.CompactTextString(m) }
func (*MsgReveal) ProtoMessage()    {}
func (*MsgReveal) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{2}
}
func (m *MsgReveal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReveal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReveal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReveal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReveal.Merge(m, src)
}
func (m *MsgReveal) XXX_Size() int {
	return m.Size()
}
func (m *MsgReveal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReveal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReveal proto.InternalMessageInfo

func (m *MsgReveal) GetCommitter() string {
	if m != nil {
		return m.Committer
	}
	return ""
}

func (m *MsgReveal) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgReveal) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

type MsgRevealResponse struct {
}

func (m *MsgRevealResponse) Reset()         { *m = MsgRevealResponse{} }
func (m *MsgRevealResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevealResponse) ProtoMessage()    {}
func (*MsgRevealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{3}
}
func (m *MsgRevealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevealResponse.Merge(m, src)
}
func (m *MsgRevealResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevealResponse proto.InternalMessageInfo

type MsgSetValuation struct {
	Owner      string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	NftClassId string     `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	NftId      string     `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Valuation  types.Coin `protobuf:"bytes,4,opt,name=valuation,proto3" json:"valuation"`
}

func (m *MsgSetValuation) Reset()         { *m = MsgSetValuation{} }
func (m *MsgSetValuation) String() string { return proto.CompactTextString(m) }
func (*MsgSetValuation) ProtoMessage()    {}
func (*MsgSetValuation) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{4}
}
func (m *MsgSetValuation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetValuation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetValuation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetValuation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetValuation.Merge(m, src)
}
func (m *MsgSetValuation) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetValuation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetValuation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetValuation proto.InternalMessageInfo

func (m *MsgSetValuation) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSetValuation) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgSetValuation) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgSetValuation) GetValuation() types.Coin {
	if m != nil {
		return m.Valuation
	}
	return types.Coin{}
}

type MsgSetValuationResponse struct {
}

func (m *MsgSetValuationResponse) Reset()         { *m = MsgSetValuationResponse{} }
func (m *MsgSetValuationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetValuationResponse) ProtoMessage()    {}
func (*MsgSetValuationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{5}
}
func (m *MsgSetValuationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetValuationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetValuationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetValuationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetValuationResponse.Merge(m, src)
}
func (m *MsgSetValuationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetValuationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetValuationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetValuationResponse proto.InternalMessageInfo

type MsgRenew struct {
	Payer      string `protobuf:"bytes,1,opt,name=payer,proto3" json:"payer,omitempty"`
	NftClassId string `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	NftId      string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *MsgRenew) Reset()         { *m = MsgRenew{} }
func (m *MsgRenew) String() string { return proto.CompactTextString(m) }
func (*MsgRenew) ProtoMessage()    {}
func (*MsgRenew) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{6}
}
func (m *MsgRenew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRenew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRenew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRenew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRenew.Merge(m, src)
}
func (m *MsgRenew) XXX_Size() int {
	return m.Size()
}
func (m *MsgRenew) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRenew.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRenew proto.InternalMessageInfo

func (m *MsgRenew) GetPayer() string {
	if m != nil {
		return m.Payer
	}
	return ""
}

func (m *MsgRenew) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgRenew) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type MsgRenewResponse struct {
	Expiry time.Time `protobuf:"bytes,1,opt,name=expiry,proto3,stdtime" json:"expiry"`
}

func (m *MsgRenewResponse) Reset()         { *m = MsgRenewResponse{} }
func (m *MsgRenewResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRenewResponse) ProtoMessage()    {}
func (*MsgRenewResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{7}
}
func (m *MsgRenewResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRenewResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRenewResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRenewResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRenewResponse.Merge(m, src)
}
func (m *MsgRenewResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRenewResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRenewResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRenewResponse proto.InternalMessageInfo

func (m *MsgRenewResponse) GetExpiry() time.Time {
	if m != nil {
		return m.Expiry
	}
	return time.Time{}
}

type MsgPlaceBid struct {
	Bidder     string     `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	NftClassId string     `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	NftId      string     `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	BidAmount  types.Coin `protobuf:"bytes,4,opt,name=bid_amount,json=bidAmount,proto3" json:"bid_amount"`
}

func (m *MsgPlaceBid) Reset()         { *m = MsgPlaceBid{} }
func (m *MsgPlaceBid) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceBid) ProtoMessage()    {}
func (*MsgPlaceBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{8}
}
func (m *MsgPlaceBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceBid.Merge(m, src)
}
func (m *MsgPlaceBid) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceBid) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceBid.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceBid proto.InternalMessageInfo

func (m *MsgPlaceBid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *MsgPlaceBid) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgPlaceBid) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgPlaceBid) GetBidAmount() types.Coin {
	if m != nil {
		return m.BidAmount
	}
	return types.Coin{}
}

type MsgPlaceBidResponse struct {
}

func (m *MsgPlaceBidResponse) Reset()         { *m = MsgPlaceBidResponse{} }
func (m *MsgPlaceBidResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceBidResponse) ProtoMessage()    {}
func (*MsgPlaceBidResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{9}
}
func (m *MsgPlaceBidResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceBidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceBidResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceBidResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceBidResponse.Merge(m, src)
}
func (m *MsgPlaceBidResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceBidResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceBidResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceBidResponse proto.InternalMessageInfo

type MsgAcceptBid struct {
	Owner      string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	NftClassId string `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	NftId      string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *MsgAcceptBid) Reset()         { *m = MsgAcceptBid{} }
func (m *MsgAcceptBid) String() string { return proto.CompactTextString(m) }
func (*MsgAcceptBid) ProtoMessage()    {}
func (*MsgAcceptBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{10}
}
func (m *MsgAcceptBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAcceptBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAcceptBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAcceptBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAcceptBid.Merge(m, src)
}
func (m *MsgAcceptBid) XXX_Size() int {
	return m.Size()
}
func (m *MsgAcceptBid) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAcceptBid.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAcceptBid proto.InternalMessageInfo

func (m *MsgAcceptBid) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgAcceptBid) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgAcceptBid) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type MsgAcceptBidResponse struct {
}

func (m *MsgAcceptBidResponse) Reset()         { *m = MsgAcceptBidResponse{} }
func (m *MsgAcceptBidResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAcceptBidResponse) ProtoMessage()    {}
func (*MsgAcceptBidResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{11}
}
func (m *MsgAcceptBidResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAcceptBidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAcceptBidResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAcceptBidResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAcceptBidResponse.Merge(m, src)
}
func (m *MsgAcceptBidResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAcceptBidResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAcceptBidResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAcceptBidResponse proto.InternalMessageInfo

type MsgRejectBid struct {
	Owner        string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	NftClassId   string     `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	NftId        string     `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	NewValuation types.Coin `protobuf:"bytes,4,opt,name=new_valuation,json=newValuation,proto3" json:"new_valuation"`
}

func (m *MsgRejectBid) Reset()         { *m = MsgRejectBid{} }
func (m *MsgRejectBid) String() string { return proto.CompactTextString(m) }
func (*MsgRejectBid) ProtoMessage()    {}
func (*MsgRejectBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{12}
}
func (m *MsgRejectBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRejectBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRejectBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRejectBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRejectBid.Merge(m, src)
}
func (m *MsgRejectBid) XXX_Size() int {
	return m.Size()
}
func (m *MsgRejectBid) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRejectBid.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRejectBid proto.InternalMessageInfo

func (m *MsgRejectBid) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgRejectBid) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgRejectBid) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgRejectBid) GetNewValuation() types.Coin {
	if m != nil {
		return m.NewValuation
	}
	return types.Coin{}
}

type MsgRejectBidResponse struct {
}

func (m *MsgRejectBidResponse) Reset()         { *m = MsgRejectBidResponse{} }
func (m *MsgRejectBidResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRejectBidResponse) ProtoMessage()    {}
func (*MsgRejectBidResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{13}
}
func (m *MsgRejectBidResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRejectBidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRejectBidResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRejectBidResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRejectBidResponse.Merge(m, src)
}
func (m *MsgRejectBidResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRejectBidResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRejectBidResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRejectBidResponse proto.InternalMessageInfo

type MsgClaimBid struct {
	Bidder     string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	NftClassId string `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	NftId      string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *MsgClaimBid) Reset()         { *m = MsgClaimBid{} }
func (m *MsgClaimBid) String() string { return proto.CompactTextString(m) }
func (*MsgClaimBid) ProtoMessage()    {}
func (*MsgClaimBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{14}
}
func (m *MsgClaimBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimBid.Merge(m, src)
}
func (m *MsgClaimBid) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimBid) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimBid.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimBid proto.InternalMessageInfo

func (m *MsgClaimBid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *MsgClaimBid) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgClaimBid) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type MsgClaimBidResponse struct {
}

func (m *MsgClaimBidResponse) Reset()         { *m = MsgClaimBidResponse{} }
func (m *MsgClaimBidResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimBidResponse) ProtoMessage()    {}
func (*MsgClaimBidResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{15}
}
func (m *MsgClaimBidResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimBidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimBidResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimBidResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimBidResponse.Merge(m, src)
}
func (m *MsgClaimBidResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimBidResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimBidResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimBidResponse proto.InternalMessageInfo

type MsgSetDestination struct {
	Owner       string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
}

func (m *MsgSetDestination) Reset()         { *m = MsgSetDestination{} }
func (m *MsgSetDestination) String() string { return proto.CompactTextString(m) }
func (*MsgSetDestination) ProtoMessage()    {}
func (*MsgSetDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{16}
}
func (m *MsgSetDestination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDestination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDestination.Merge(m, src)
}
func (m *MsgSetDestination) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDestination.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDestination proto.InternalMessageInfo

func (m *MsgSetDestination) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSetDestination) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgSetDestination) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type MsgSetDestinationResponse struct {
}

func (m *MsgSetDestinationResponse) Reset()         { *m = MsgSetDestinationResponse{} }
func (m *MsgSetDestinationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetDestinationResponse) ProtoMessage()    {}
func (*MsgSetDestinationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{17}
}
func (m *MsgSetDestinationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDestinationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDestinationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDestinationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDestinationResponse.Merge(m, src)
}
func (m *MsgSetDestinationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDestinationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDestinationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDestinationResponse proto.InternalMessageInfo

type MsgSetNFTMetadata struct {
	Owner    string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClassId  string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	NftId    string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Uri      string `protobuf:"bytes,5,opt,name=uri,proto3" json:"uri,omitempty"`
}

func (m *MsgSetNFTMetadata) Reset()         { *m = MsgSetNFTMetadata{} }
func (m *MsgSetNFTMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTMetadata) ProtoMessage()    {}
func (*MsgSetNFTMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{18}
}
func (m *MsgSetNFTMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTMetadata.Merge(m, src)
}
func (m *MsgSetNFTMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTMetadata proto.InternalMessageInfo

func (m *MsgSetNFTMetadata) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSetNFTMetadata) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgSetNFTMetadata) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgSetNFTMetadata) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *MsgSetNFTMetadata) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

type MsgSetNFTMetadataResponse struct {
}

func (m *MsgSetNFTMetadataResponse) Reset()         { *m = MsgSetNFTMetadataResponse{} }
func (m *MsgSetNFTMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTMetadataResponse) ProtoMessage()    {}
func (*MsgSetNFTMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{19}
}
func (m *MsgSetNFTMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTMetadataResponse.Merge(m, src)
}
func (m *MsgSetNFTMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTMetadataResponse proto.InternalMessageInfo

type MsgSetNFTClassExtraData struct {
	Owner     string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClassId   string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	ExtraData string `protobuf:"bytes,3,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
}

func (m *MsgSetNFTClassExtraData) Reset()         { *m = MsgSetNFTClassExtraData{} }
func (m *MsgSetNFTClassExtraData) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTClassExtraData) ProtoMessage()    {}
func (*MsgSetNFTClassExtraData) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{20}
}
func (m *MsgSetNFTClassExtraData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTClassExtraData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTClassExtraData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTClassExtraData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTClassExtraData.Merge(m, src)
}
func (m *MsgSetNFTClassExtraData) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTClassExtraData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTClassExtraData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTClassExtraData proto.InternalMessageInfo

func (m *MsgSetNFTClassExtraData) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSetNFTClassExtraData) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgSetNFTClassExtraData) GetExtraData() string {
	if m != nil {
		return m.ExtraData
	}
	return ""
}

type MsgSetNFTClassExtraDataResponse struct {
}

func (m *MsgSetNFTClassExtraDataResponse) Reset()         { *m = MsgSetNFTClassExtraDataResponse{} }
func (m *MsgSetNFTClassExtraDataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTClassExtraDataResponse) ProtoMessage()    {}
func (*MsgSetNFTClassExtraDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{21}
}
func (m *MsgSetNFTClassExtraDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTClassExtraDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTClassExtraDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTClassExtraDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTClassExtraDataResponse.Merge(m, src)
}
func (m *MsgSetNFTClassExtraDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTClassExtraDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTClassExtraDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTClassExtraDataResponse proto.InternalMessageInfo

// MsgSetNFTClassAlwaysListed sets the always_listed flag for an NFT class.
// Only the owner of the NFT class root name can update this setting.
type MsgSetNFTClassAlwaysListed struct {
	// owner is the address of the NFT class root name owner
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// class_id is the identifier of the NFT class to update
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// always_listed determines if NFTs in this class should always be listed for
	// sale and override the listed status of the individual NFTs
	AlwaysListed bool `protobuf:"varint,3,opt,name=always_listed,json=alwaysListed,proto3" json:"always_listed,omitempty"`
}

func (m *MsgSetNFTClassAlwaysListed) Reset()         { *m = MsgSetNFTClassAlwaysListed{} }
func (m *MsgSetNFTClassAlwaysListed) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTClassAlwaysListed) ProtoMessage()    {}
func (*MsgSetNFTClassAlwaysListed) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{22}
}
func (m *MsgSetNFTClassAlwaysListed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTClassAlwaysListed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTClassAlwaysListed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTClassAlwaysListed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTClassAlwaysListed.Merge(m, src)
}
func (m *MsgSetNFTClassAlwaysListed) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTClassAlwaysListed) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTClassAlwaysListed.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTClassAlwaysListed proto.InternalMessageInfo

func (m *MsgSetNFTClassAlwaysListed) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSetNFTClassAlwaysListed) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgSetNFTClassAlwaysListed) GetAlwaysListed() bool {
	if m != nil {
		return m.AlwaysListed
	}
	return false
}

// MsgSetNFTClassAlwaysListedResponse defines the response for
// MsgSetNFTClassAlwaysListed
type MsgSetNFTClassAlwaysListedResponse struct {
}

func (m *MsgSetNFTClassAlwaysListedResponse) Reset()         { *m = MsgSetNFTClassAlwaysListedResponse{} }
func (m *MsgSetNFTClassAlwaysListedResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTClassAlwaysListedResponse) ProtoMessage()    {}
func (*MsgSetNFTClassAlwaysListedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{23}
}
func (m *MsgSetNFTClassAlwaysListedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTClassAlwaysListedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTClassAlwaysListedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTClassAlwaysListedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTClassAlwaysListedResponse.Merge(m, src)
}
func (m *MsgSetNFTClassAlwaysListedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTClassAlwaysListedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTClassAlwaysListedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTClassAlwaysListedResponse proto.InternalMessageInfo

// MsgSetNFTClassAnnualPct sets the annual percentage rate for an NFT class.
// Only the owner of the NFT class root name can update this setting.
type MsgSetNFTClassAnnualPct struct {
	// owner is the address of the NFT class root name owner
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// class_id is the identifier of the NFT class to update
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// annual_pct is the annual percentage rate as a string (e.g. "5.5" for 5.5%)
	// representing the yearly rate for this NFT class
	AnnualPct string `protobuf:"bytes,3,opt,name=annual_pct,json=annualPct,proto3" json:"annual_pct,omitempty"`
}

func (m *MsgSetNFTClassAnnualPct) Reset()         { *m = MsgSetNFTClassAnnualPct{} }
func (m *MsgSetNFTClassAnnualPct) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTClassAnnualPct) ProtoMessage()    {}
func (*MsgSetNFTClassAnnualPct) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{24}
}
func (m *MsgSetNFTClassAnnualPct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTClassAnnualPct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTClassAnnualPct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTClassAnnualPct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTClassAnnualPct.Merge(m, src)
}
func (m *MsgSetNFTClassAnnualPct) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTClassAnnualPct) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTClassAnnualPct.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTClassAnnualPct proto.InternalMessageInfo

func (m *MsgSetNFTClassAnnualPct) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSetNFTClassAnnualPct) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgSetNFTClassAnnualPct) GetAnnualPct() string {
	if m != nil {
		return m.AnnualPct
	}
	return ""
}

// MsgSetNFTClassAnnualPctResponse defines the response for
// MsgSetNFTClassAnnualPct
type MsgSetNFTClassAnnualPctResponse struct {
}

func (m *MsgSetNFTClassAnnualPctResponse) Reset()         { *m = MsgSetNFTClassAnnualPctResponse{} }
func (m *MsgSetNFTClassAnnualPctResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetNFTClassAnnualPctResponse) ProtoMessage()    {}
func (*MsgSetNFTClassAnnualPctResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{25}
}
func (m *MsgSetNFTClassAnnualPctResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetNFTClassAnnualPctResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetNFTClassAnnualPctResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetNFTClassAnnualPctResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetNFTClassAnnualPctResponse.Merge(m, src)
}
func (m *MsgSetNFTClassAnnualPctResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetNFTClassAnnualPctResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetNFTClassAnnualPctResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetNFTClassAnnualPctResponse proto.InternalMessageInfo

// MsgSetListed sets the listed status for a specific NFT.
// Only the owner of the NFT can update this setting.
type MsgSetListed struct {
	// nft_owner is the address of the NFT owner
	NftOwner string `protobuf:"bytes,1,opt,name=nft_owner,json=nftOwner,proto3" json:"nft_owner,omitempty"`
	// nft_class_id is the identifier of the NFT class
	NftClassId string `protobuf:"bytes,2,opt,name=nft_class_id,json=nftClassId,proto3" json:"nft_class_id,omitempty"`
	// nft_id is the identifier of the specific NFT
	NftId string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	// listed determines if the NFT should be listed for sale but is overridden by
	// the NFTClass.always_listed parameter.
	Listed bool `protobuf:"varint,4,opt,name=listed,proto3" json:"listed,omitempty"`
}

func (m *MsgSetListed) Reset()         { *m = MsgSetListed{} }
func (m *MsgSetListed) String() string { return proto.CompactTextString(m) }
func (*MsgSetListed) ProtoMessage()    {}
func (*MsgSetListed) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{26}
}
func (m *MsgSetListed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetListed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetListed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetListed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetListed.Merge(m, src)
}
func (m *MsgSetListed) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetListed) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetListed.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetListed proto.InternalMessageInfo

func (m *MsgSetListed) GetNftOwner() string {
	if m != nil {
		return m.NftOwner
	}
	return ""
}

func (m *MsgSetListed) GetNftClassId() string {
	if m != nil {
		return m.NftClassId
	}
	return ""
}

func (m *MsgSetListed) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgSetListed) GetListed() bool {
	if m != nil {
		return m.Listed
	}
	return false
}

// MsgSetListedResponse defines the response for MsgSetListed
type MsgSetListedResponse struct {
}

func (m *MsgSetListedResponse) Reset()         { *m = MsgSetListedResponse{} }
func (m *MsgSetListedResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetListedResponse) ProtoMessage()    {}
func (*MsgSetListedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{27}
}
func (m *MsgSetListedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetListedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetListedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetListedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetListedResponse.Merge(m, src)
}
func (m *MsgSetListedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetListedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetListedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetListedResponse proto.InternalMessageInfo

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless
	// overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the x/nameservice parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{28}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{29}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgMintCoins mints coins into the owner's balance, as long as each coin's
// "root name" is owned by that owner.
type MsgMintCoins struct {
	// Owner must be a valid address
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// Using repeated cosmos.base.v1beta1.Coin with the annotation
	// (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
	// so that the generated Go code will have `Amount sdk.Coins` automatically.
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
}

func (m *MsgMintCoins) Reset()         { *m = MsgMintCoins{} }
func (m *MsgMintCoins) String() string { return proto.CompactTextString(m) }
func (*MsgMintCoins) ProtoMessage()    {}
func (*MsgMintCoins) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{30}
}
func (m *MsgMintCoins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintCoins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintCoins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintCoins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintCoins.Merge(m, src)
}
func (m *MsgMintCoins) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintCoins) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintCoins.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintCoins proto.InternalMessageInfo

func (m *MsgMintCoins) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgMintCoins) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Response for MintCoins
type MsgMintCoinsResponse struct {
}

func (m *MsgMintCoinsResponse) Reset()         { *m = MsgMintCoinsResponse{} }
func (m *MsgMintCoinsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintCoinsResponse) ProtoMessage()    {}
func (*MsgMintCoinsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{31}
}
func (m *MsgMintCoinsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintCoinsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintCoinsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintCoinsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintCoinsResponse.Merge(m, src)
}
func (m *MsgMintCoinsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintCoinsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintCoinsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintCoinsResponse proto.InternalMessageInfo

// MsgBurnCoins burns coins from the owner's balance, if each coin's root name
// is owned by that owner.
type MsgBurnCoins struct {
	// Owner address
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// Using the same annotation as MintCoins for consistency
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
}

func (m *MsgBurnCoins) Reset()         { *m = MsgBurnCoins{} }
func (m *MsgBurnCoins) String() string { return proto.CompactTextString(m) }
func (*MsgBurnCoins) ProtoMessage()    {}
func (*MsgBurnCoins) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{32}
}
func (m *MsgBurnCoins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnCoins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnCoins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnCoins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnCoins.Merge(m, src)
}
func (m *MsgBurnCoins) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnCoins) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnCoins.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnCoins proto.InternalMessageInfo

func (m *MsgBurnCoins) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgBurnCoins) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Response for BurnCoins
type MsgBurnCoinsResponse struct {
}

func (m *MsgBurnCoinsResponse) Reset()         { *m = MsgBurnCoinsResponse{} }
func (m *MsgBurnCoinsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnCoinsResponse) ProtoMessage()    {}
func (*MsgBurnCoinsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{33}
}
func (m *MsgBurnCoinsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnCoinsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnCoinsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnCoinsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnCoinsResponse.Merge(m, src)
}
func (m *MsgBurnCoinsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnCoinsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnCoinsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnCoinsResponse proto.InternalMessageInfo

// MsgSetDenomMetadata allows a governance-authorized account to set denom
// metadata.
type MsgSetDenomMetadata struct {
	// authority is the address that controls the module (defaults to x/gov unless
	// overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// The bank module metadata describing the denom, display, base, etc.
	Metadata types1.Metadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata"`
}

func (m *MsgSetDenomMetadata) Reset()         { *m = MsgSetDenomMetadata{} }
func (m *MsgSetDenomMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetDenomMetadata) ProtoMessage()    {}
func (*MsgSetDenomMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{34}
}
func (m *MsgSetDenomMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDenomMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDenomMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDenomMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDenomMetadata.Merge(m, src)
}
func (m *MsgSetDenomMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDenomMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDenomMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDenomMetadata proto.InternalMessageInfo

func (m *MsgSetDenomMetadata) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgSetDenomMetadata) GetMetadata() types1.Metadata {
	if m != nil {
		return m.Metadata
	}
	return types1.Metadata{}
}

// MsgSetDenomMetadataResponse defines the response structure for executing a
// MsgSetDenomMetadata message.
type MsgSetDenomMetadataResponse struct {
}

func (m *MsgSetDenomMetadataResponse) Reset()         { *m = MsgSetDenomMetadataResponse{} }
func (m *MsgSetDenomMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetDenomMetadataResponse) ProtoMessage()    {}
func (*MsgSetDenomMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{35}
}
func (m *MsgSetDenomMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDenomMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDenomMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDenomMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDenomMetadataResponse.Merge(m, src)
}
func (m *MsgSetDenomMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDenomMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDenomMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDenomMetadataResponse proto.InternalMessageInfo

// SaveClass
type MsgSaveClass struct {
	Owner       string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClassId     string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Symbol      string `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Uri         string `protobuf:"bytes,6,opt,name=uri,proto3" json:"uri,omitempty"`
	UriHash     string `protobuf:"bytes,7,opt,name=uri_hash,json=uriHash,proto3" json:"uri_hash,omitempty"`
}

func (m *MsgSaveClass) Reset()         { *m = MsgSaveClass{} }
func (m *MsgSaveClass) String() string { return proto.CompactTextString(m) }
func (*MsgSaveClass) ProtoMessage()    {}
func (*MsgSaveClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{36}
}
func (m *MsgSaveClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSaveClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSaveClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSaveClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSaveClass.Merge(m, src)
}
func (m *MsgSaveClass) XXX_Size() int {
	return m.Size()
}
func (m *MsgSaveClass) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSaveClass.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSaveClass proto.InternalMessageInfo

func (m *MsgSaveClass) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgSaveClass) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgSaveClass) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgSaveClass) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *MsgSaveClass) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgSaveClass) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MsgSaveClass) GetUriHash() string {
	if m != nil {
		return m.UriHash
	}
	return ""
}

type MsgSaveClassResponse struct {
}

func (m *MsgSaveClassResponse) Reset()         { *m = MsgSaveClassResponse{} }
func (m *MsgSaveClassResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSaveClassResponse) ProtoMessage()    {}
func (*MsgSaveClassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{37}
}
func (m *MsgSaveClassResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSaveClassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSaveClassResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSaveClassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSaveClassResponse.Merge(m, src)
}
func (m *MsgSaveClassResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSaveClassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSaveClassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSaveClassResponse proto.InternalMessageInfo

// MintNFT
type MsgMintNFT struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	NftId   string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Uri     string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	UriHash string `protobuf:"bytes,5,opt,name=uri_hash,json=uriHash,proto3" json:"uri_hash,omitempty"`
}

func (m *MsgMintNFT) Reset()         { *m = MsgMintNFT{} }
func (m *MsgMintNFT) String() string { return proto.CompactTextString(m) }
func (*MsgMintNFT) ProtoMessage()    {}
func (*MsgMintNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{38}
}
func (m *MsgMintNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintNFT.Merge(m, src)
}
func (m *MsgMintNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintNFT proto.InternalMessageInfo

func (m *MsgMintNFT) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgMintNFT) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgMintNFT) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgMintNFT) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MsgMintNFT) GetUriHash() string {
	if m != nil {
		return m.UriHash
	}
	return ""
}

type MsgMintNFTResponse struct {
}

func (m *MsgMintNFTResponse) Reset()         { *m = MsgMintNFTResponse{} }
func (m *MsgMintNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintNFTResponse) ProtoMessage()    {}
func (*MsgMintNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{39}
}
func (m *MsgMintNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintNFTResponse.Merge(m, src)
}
func (m *MsgMintNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintNFTResponse proto.InternalMessageInfo

// BurnNFT
type MsgBurnNFT struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	NftId   string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *MsgBurnNFT) Reset()         { *m = MsgBurnNFT{} }
func (m *MsgBurnNFT) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNFT) ProtoMessage()    {}
func (*MsgBurnNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{40}
}
func (m *MsgBurnNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNFT.Merge(m, src)
}
func (m *MsgBurnNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNFT proto.InternalMessageInfo

func (m *MsgBurnNFT) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgBurnNFT) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgBurnNFT) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type MsgBurnNFTResponse struct {
}

func (m *MsgBurnNFTResponse) Reset()         { *m = MsgBurnNFTResponse{} }
func (m *MsgBurnNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNFTResponse) ProtoMessage()    {}
func (*MsgBurnNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{41}
}
func (m *MsgBurnNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNFTResponse.Merge(m, src)
}
func (m *MsgBurnNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNFTResponse proto.InternalMessageInfo

// MsgMoveCoins force moves custom denom coins between two accounts if signer
// owns the root name of each coin denom.
type MsgMoveCoins struct {
	// Signer must own the root name of each coin denoms in all inputs.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// One or multiple inputs: each account holding the coins.
	Inputs []types1.Input `protobuf:"bytes,2,rep,name=inputs,proto3" json:"inputs"`
	// One or multiple outputs: the account receiving the coins.
	Outputs []types1.Output `protobuf:"bytes,3,rep,name=outputs,proto3" json:"outputs"`
}

func (m *MsgMoveCoins) Reset()         { *m = MsgMoveCoins{} }
func (m *MsgMoveCoins) String() string { return proto.CompactTextString(m) }
func (*MsgMoveCoins) ProtoMessage()    {}
func (*MsgMoveCoins) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{42}
}
func (m *MsgMoveCoins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMoveCoins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMoveCoins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMoveCoins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMoveCoins.Merge(m, src)
}
func (m *MsgMoveCoins) XXX_Size() int {
	return m.Size()
}
func (m *MsgMoveCoins) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMoveCoins.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMoveCoins proto.InternalMessageInfo

func (m *MsgMoveCoins) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgMoveCoins) GetInputs() []types1.Input {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *MsgMoveCoins) GetOutputs() []types1.Output {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type MsgMoveCoinsResponse struct {
}

func (m *MsgMoveCoinsResponse) Reset()         { *m = MsgMoveCoinsResponse{} }
func (m *MsgMoveCoinsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMoveCoinsResponse) ProtoMessage()    {}
func (*MsgMoveCoinsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{43}
}
func (m *MsgMoveCoinsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMoveCoinsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMoveCoinsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMoveCoinsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMoveCoinsResponse.Merge(m, src)
}
func (m *MsgMoveCoinsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMoveCoinsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMoveCoinsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMoveCoinsResponse proto.InternalMessageInfo

// MsgMoveNft force moves an NFT between accounts when signer owns the NFT
// class.
type MsgMoveNft struct {
	// Signer owning class root name
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// NFT class ID
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// NFT ID
	NftId string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	// Destination holder (non-module)
	ToAddress string `protobuf:"bytes,4,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`
}

func (m *MsgMoveNft) Reset()         { *m = MsgMoveNft{} }
func (m *MsgMoveNft) String() string { return proto.CompactTextString(m) }
func (*MsgMoveNft) ProtoMessage()    {}
func (*MsgMoveNft) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{44}
}
func (m *MsgMoveNft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMoveNft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMoveNft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMoveNft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMoveNft.Merge(m, src)
}
func (m *MsgMoveNft) XXX_Size() int {
	return m.Size()
}
func (m *MsgMoveNft) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMoveNft.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMoveNft proto.InternalMessageInfo

func (m *MsgMoveNft) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgMoveNft) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgMoveNft) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *MsgMoveNft) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

type MsgMoveNftResponse struct {
}

func (m *MsgMoveNftResponse) Reset()         { *m = MsgMoveNftResponse{} }
func (m *MsgMoveNftResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMoveNftResponse) ProtoMessage()    {}
func (*MsgMoveNftResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870e08f0445a3564, []int{45}
}
func (m *MsgMoveNftResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMoveNftResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMoveNftResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMoveNftResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMoveNftResponse.Merge(m, src)
}
func (m *MsgMoveNftResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMoveNftResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMoveNftResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMoveNftResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCommit)(nil), "dysonprotocol.nameservice.v1.MsgCommit")
	proto.RegisterType((*MsgCommitResponse)(nil), "dysonprotocol.nameservice.v1.MsgCommitResponse")
	proto.RegisterType((*MsgReveal)(nil), "dysonprotocol.nameservice.v1.MsgReveal")
	proto.RegisterType((*MsgRevealResponse)(nil), "dysonprotocol.nameservice.v1.MsgRevealResponse")
	proto.RegisterType((*MsgSetValuation)(nil), "dysonprotocol.nameservice.v1.MsgSetValuation")
	proto.RegisterType((*MsgSetValuationResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetValuationResponse")
	proto.RegisterType((*MsgRenew)(nil), "dysonprotocol.nameservice.v1.MsgRenew")
	proto.RegisterType((*MsgRenewResponse)(nil), "dysonprotocol.nameservice.v1.MsgRenewResponse")
	proto.RegisterType((*MsgPlaceBid)(nil), "dysonprotocol.nameservice.v1.MsgPlaceBid")
	proto.RegisterType((*MsgPlaceBidResponse)(nil), "dysonprotocol.nameservice.v1.MsgPlaceBidResponse")
	proto.RegisterType((*MsgAcceptBid)(nil), "dysonprotocol.nameservice.v1.MsgAcceptBid")
	proto.RegisterType((*MsgAcceptBidResponse)(nil), "dysonprotocol.nameservice.v1.MsgAcceptBidResponse")
	proto.RegisterType((*MsgRejectBid)(nil), "dysonprotocol.nameservice.v1.MsgRejectBid")
	proto.RegisterType((*MsgRejectBidResponse)(nil), "dysonprotocol.nameservice.v1.MsgRejectBidResponse")
	proto.RegisterType((*MsgClaimBid)(nil), "dysonprotocol.nameservice.v1.MsgClaimBid")
	proto.RegisterType((*MsgClaimBidResponse)(nil), "dysonprotocol.nameservice.v1.MsgClaimBidResponse")
	proto.RegisterType((*MsgSetDestination)(nil), "dysonprotocol.nameservice.v1.MsgSetDestination")
	proto.RegisterType((*MsgSetDestinationResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetDestinationResponse")
	proto.RegisterType((*MsgSetNFTMetadata)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTMetadata")
	proto.RegisterType((*MsgSetNFTMetadataResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTMetadataResponse")
	proto.RegisterType((*MsgSetNFTClassExtraData)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTClassExtraData")
	proto.RegisterType((*MsgSetNFTClassExtraDataResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTClassExtraDataResponse")
	proto.RegisterType((*MsgSetNFTClassAlwaysListed)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTClassAlwaysListed")
	proto.RegisterType((*MsgSetNFTClassAlwaysListedResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTClassAlwaysListedResponse")
	proto.RegisterType((*MsgSetNFTClassAnnualPct)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTClassAnnualPct")
	proto.RegisterType((*MsgSetNFTClassAnnualPctResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetNFTClassAnnualPctResponse")
	proto.RegisterType((*MsgSetListed)(nil), "dysonprotocol.nameservice.v1.MsgSetListed")
	proto.RegisterType((*MsgSetListedResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetListedResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "dysonprotocol.nameservice.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "dysonprotocol.nameservice.v1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgMintCoins)(nil), "dysonprotocol.nameservice.v1.MsgMintCoins")
	proto.RegisterType((*MsgMintCoinsResponse)(nil), "dysonprotocol.nameservice.v1.MsgMintCoinsResponse")
	proto.RegisterType((*MsgBurnCoins)(nil), "dysonprotocol.nameservice.v1.MsgBurnCoins")
	proto.RegisterType((*MsgBurnCoinsResponse)(nil), "dysonprotocol.nameservice.v1.MsgBurnCoinsResponse")
	proto.RegisterType((*MsgSetDenomMetadata)(nil), "dysonprotocol.nameservice.v1.MsgSetDenomMetadata")
	proto.RegisterType((*MsgSetDenomMetadataResponse)(nil), "dysonprotocol.nameservice.v1.MsgSetDenomMetadataResponse")
	proto.RegisterType((*MsgSaveClass)(nil), "dysonprotocol.nameservice.v1.MsgSaveClass")
	proto.RegisterType((*MsgSaveClassResponse)(nil), "dysonprotocol.nameservice.v1.MsgSaveClassResponse")
	proto.RegisterType((*MsgMintNFT)(nil), "dysonprotocol.nameservice.v1.MsgMintNFT")
	proto.RegisterType((*MsgMintNFTResponse)(nil), "dysonprotocol.nameservice.v1.MsgMintNFTResponse")
	proto.RegisterType((*MsgBurnNFT)(nil), "dysonprotocol.nameservice.v1.MsgBurnNFT")
	proto.RegisterType((*MsgBurnNFTResponse)(nil), "dysonprotocol.nameservice.v1.MsgBurnNFTResponse")
	proto.RegisterType((*MsgMoveCoins)(nil), "dysonprotocol.nameservice.v1.MsgMoveCoins")
	proto.RegisterType((*MsgMoveCoinsResponse)(nil), "dysonprotocol.nameservice.v1.MsgMoveCoinsResponse")
	proto.RegisterType((*MsgMoveNft)(nil), "dysonprotocol.nameservice.v1.MsgMoveNft")
	proto.RegisterType((*MsgMoveNftResponse)(nil), "dysonprotocol.nameservice.v1.MsgMoveNftResponse")
}

func init() {
	proto.RegisterFile("dysonprotocol/nameservice/v1/tx.proto", fileDescriptor_870e08f0445a3564)
}

var fileDescriptor_870e08f0445a3564 = []byte{
	// 1722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x36, 0x89, 0x13, 0xbf, 0xa4, 0xa5, 0xdd, 0xa6, 0x6d, 0xb2, 0xa5, 0x49, 0x08, 0x05,
	0xd2, 0x48, 0xb5, 0x9b, 0xa0, 0xd2, 0x52, 0xa8, 0x4a, 0x9c, 0x12, 0x11, 0x89, 0xa4, 0x91, 0x13,
	0x7a, 0xe0, 0x62, 0x8d, 0x77, 0x27, 0xce, 0x12, 0xef, 0xae, 0xe5, 0x19, 0x3b, 0x71, 0x39, 0x50,
	0x81, 0xb8, 0x21, 0xd1, 0x0b, 0x12, 0x42, 0x02, 0x6e, 0x80, 0x10, 0x12, 0x91, 0xe0, 0x1f, 0xe0,
	0x80, 0x54, 0x71, 0x40, 0x15, 0x07, 0xc4, 0x89, 0x56, 0xed, 0x21, 0xff, 0x06, 0x9a, 0x8f, 0x1d,
	0xaf, 0x9d, 0x8d, 0x3d, 0x36, 0x51, 0x2e, 0xc9, 0x7e, 0xbc, 0x37, 0xef, 0xf7, 0x7b, 0xf3, 0xe6,
	0x7d, 0xac, 0xe1, 0x25, 0xa7, 0x46, 0x02, 0xbf, 0x54, 0x0e, 0x68, 0x60, 0x07, 0xc5, 0xb4, 0x8f,
	0x3c, 0x4c, 0x70, 0xb9, 0xea, 0xda, 0x38, 0x5d, 0x9d, 0x4d, 0xd3, 0x9d, 0x14, 0x7f, 0x65, 0x3e,
	0xdf, 0x20, 0x96, 0x8a, 0x88, 0xa5, 0xaa, 0xb3, 0xd6, 0xb8, 0x1d, 0x10, 0x2f, 0x20, 0xe9, 0x3c,
	0x22, 0x4c, 0x2d, 0x8f, 0x29, 0x9a, 0x4d, 0xdb, 0x81, 0xeb, 0x0b, 0x6d, 0x6b, 0xa4, 0x10, 0x14,
	0x02, 0x7e, 0x99, 0x66, 0x57, 0xf2, 0xe9, 0x98, 0xd0, 0xca, 0x89, 0x17, 0xe2, 0x46, 0xbe, 0x3a,
	0x27, 0x17, 0xf4, 0x48, 0x81, 0xc1, 0xf0, 0x48, 0x41, 0xbe, 0xb8, 0xd4, 0x12, 0x6e, 0x09, 0x95,
	0x91, 0x17, 0xae, 0x31, 0x51, 0x08, 0x82, 0x42, 0x11, 0xa7, 0xf9, 0x5d, 0xbe, 0xb2, 0x91, 0xa6,
	0xae, 0x87, 0x09, 0x45, 0x5e, 0x49, 0x0a, 0x9c, 0x42, 0x9e, 0xeb, 0x07, 0x69, 0xfe, 0x57, 0x3e,
	0xaa, 0x13, 0xf1, 0xb7, 0x14, 0x11, 0x76, 0x23, 0xde, 0x4f, 0xfd, 0x64, 0x40, 0x72, 0x99, 0x14,
	0x16, 0x02, 0xcf, 0x73, 0xa9, 0xf9, 0x1a, 0x24, 0x6d, 0x7e, 0x45, 0x71, 0x79, 0xd4, 0x98, 0x34,
	0xa6, 0x93, 0x99, 0xd1, 0xbf, 0x7e, 0xbd, 0x3c, 0x22, 0xa9, 0xcc, 0x3b, 0x4e, 0x19, 0x13, 0xb2,
	0x46, 0xcb, 0xae, 0x5f, 0xc8, 0xd6, 0x45, 0xcd, 0x51, 0x18, 0xd8, 0xc4, 0x3b, 0x9b, 0x88, 0x6c,
	0x8e, 0x1e, 0x63, 0x5a, 0xd9, 0xf0, 0xd6, 0xbc, 0x09, 0xc9, 0x2a, 0x2a, 0x56, 0x10, 0x75, 0x03,
	0x7f, 0xb4, 0x77, 0xd2, 0x98, 0x1e, 0x9a, 0x1b, 0x4b, 0xc9, 0xe5, 0x98, 0x73, 0x53, 0x12, 0x53,
	0x6a, 0x21, 0x70, 0xfd, 0x4c, 0xdf, 0xc3, 0x7f, 0x27, 0x7a, 0xb2, 0x75, 0x8d, 0x1b, 0x27, 0x3e,
	0xde, 0xdb, 0x9d, 0xa9, 0x1b, 0x9a, 0x3a, 0x0d, 0xa7, 0x14, 0xda, 0x2c, 0x26, 0xa5, 0xc0, 0x27,
	0x78, 0xea, 0x43, 0x4e, 0x21, 0x8b, 0xab, 0x18, 0x15, 0xbb, 0xa6, 0x60, 0x42, 0x1f, 0xf3, 0xbd,
	0xc4, 0xcf, 0xaf, 0xd9, 0x33, 0x82, 0x8a, 0x94, 0xe3, 0x4e, 0x66, 0xf9, 0xf5, 0x01, 0x88, 0x84,
	0x71, 0x85, 0xe8, 0x0f, 0x03, 0x9e, 0x5b, 0x26, 0x85, 0x35, 0x4c, 0xef, 0x86, 0x54, 0xcc, 0x14,
	0xf4, 0x07, 0xdb, 0xbe, 0x06, 0x28, 0x21, 0x66, 0x4e, 0xc2, 0xb0, 0xbf, 0x41, 0x73, 0x76, 0x11,
	0x11, 0x92, 0x73, 0x1d, 0x09, 0x0c, 0xfc, 0x0d, 0xba, 0xc0, 0x1e, 0x2d, 0x39, 0xe6, 0x19, 0x48,
	0x30, 0x09, 0xd7, 0x91, 0x00, 0xfb, 0xfd, 0x0d, 0xba, 0xe4, 0x98, 0x99, 0xa8, 0xcb, 0xfb, 0xda,
	0xb9, 0x3c, 0xc9, 0x5c, 0xfe, 0xc3, 0xde, 0xee, 0x8c, 0x11, 0xf5, 0x3b, 0x30, 0x96, 0x02, 0xc8,
	0xd4, 0x18, 0x9c, 0x6b, 0xe2, 0xa2, 0x78, 0x7e, 0x04, 0x83, 0x9c, 0xbc, 0x8f, 0xb7, 0x19, 0xbf,
	0x12, 0xaa, 0xe9, 0xf0, 0xe3, 0x62, 0x5d, 0xf3, 0x93, 0xd8, 0xf8, 0x22, 0x53, 0xab, 0x70, 0x32,
	0x04, 0x10, 0x82, 0x32, 0xdf, 0x84, 0x04, 0xde, 0x29, 0xb9, 0xe5, 0x1a, 0x47, 0x32, 0x34, 0x67,
	0xa5, 0xc4, 0xb9, 0x49, 0x85, 0xe7, 0x26, 0xb5, 0x1e, 0x9e, 0x9b, 0xcc, 0x20, 0x63, 0xff, 0xe0,
	0xf1, 0x84, 0x91, 0x95, 0x3a, 0x6c, 0xeb, 0x86, 0x96, 0x49, 0x61, 0xb5, 0x88, 0x6c, 0x9c, 0x71,
	0x1d, 0xf3, 0x0a, 0x24, 0xf2, 0xae, 0xe3, 0x68, 0xf0, 0x92, 0x72, 0xdd, 0x6f, 0xdc, 0x02, 0x40,
	0xde, 0x75, 0x72, 0xc8, 0x0b, 0x2a, 0x3e, 0xed, 0x6c, 0xe7, 0xf2, 0xae, 0x33, 0xcf, 0xd5, 0x6e,
	0x0c, 0x31, 0xef, 0x48, 0x28, 0x53, 0x67, 0xe0, 0x74, 0x84, 0x8b, 0xda, 0xb6, 0x4f, 0x0c, 0x18,
	0x5e, 0x26, 0x85, 0x79, 0xdb, 0xc6, 0x25, 0xca, 0x48, 0x1e, 0x55, 0x6c, 0x36, 0xc4, 0xd5, 0x59,
	0x18, 0x89, 0x82, 0x50, 0xe8, 0xfe, 0x14, 0xe8, 0xb2, 0xf8, 0x03, 0x6c, 0x1f, 0x29, 0x3a, 0x73,
	0x09, 0x8e, 0xfb, 0x78, 0x3b, 0xd7, 0xdd, 0xe9, 0x19, 0xf6, 0xf1, 0xf6, 0xdd, 0xd8, 0x03, 0x24,
	0x88, 0x2a, 0x3e, 0x8a, 0xe8, 0xa7, 0x22, 0xd4, 0x16, 0x8a, 0xc8, 0xf5, 0x8e, 0x36, 0xd4, 0xe2,
	0xa2, 0x24, 0x84, 0xa1, 0xe0, 0x7d, 0x6b, 0xf0, 0xd4, 0xb6, 0x86, 0xe9, 0x6d, 0x4c, 0xa8, 0xeb,
	0x77, 0x97, 0xc6, 0xe2, 0xf2, 0xea, 0x0d, 0x18, 0x72, 0xea, 0x4b, 0x0a, 0x64, 0x2d, 0x56, 0x8a,
	0x0a, 0x37, 0x38, 0xf6, 0x3c, 0x8c, 0xed, 0x03, 0xa8, 0xe0, 0xff, 0xac, 0xe0, 0xaf, 0x2c, 0xae,
	0x2f, 0x63, 0x8a, 0x1c, 0x44, 0x51, 0xc7, 0xf0, 0xc7, 0x60, 0xb0, 0xc9, 0xbb, 0x03, 0x76, 0xeb,
	0x20, 0xb2, 0x60, 0xd0, 0x93, 0xd6, 0x78, 0xfc, 0x24, 0xb3, 0xea, 0xde, 0x3c, 0x09, 0xbd, 0x95,
	0xb2, 0x3b, 0xda, 0xcf, 0x1f, 0xb3, 0xcb, 0x78, 0x3a, 0x11, 0xc0, 0x8a, 0xce, 0xe7, 0x46, 0x98,
	0x86, 0x57, 0x16, 0xd7, 0xf9, 0xee, 0xbe, 0xbd, 0x43, 0xcb, 0xe8, 0xf6, 0x21, 0x93, 0xba, 0x00,
	0x80, 0xd9, 0xba, 0x39, 0x8e, 0x5f, 0x10, 0x4b, 0xe2, 0xd0, 0x52, 0x03, 0xdc, 0x17, 0x60, 0xe2,
	0x00, 0x40, 0x0a, 0xf4, 0x97, 0x06, 0x58, 0x8d, 0x32, 0xf3, 0xc5, 0x6d, 0x54, 0x23, 0xef, 0xba,
	0x84, 0x62, 0xe7, 0x30, 0x71, 0xbf, 0x08, 0xc7, 0x11, 0x5f, 0x3a, 0x57, 0xe4, 0x6b, 0x73, 0xe8,
	0x83, 0xd9, 0x61, 0x14, 0xb1, 0xd7, 0x80, 0xfe, 0x22, 0x4c, 0x1d, 0x8c, 0xac, 0x85, 0xd7, 0xe7,
	0x7d, 0xbf, 0x82, 0x8a, 0xab, 0x36, 0x3d, 0x64, 0xaf, 0x23, 0xbe, 0x6e, 0xae, 0x64, 0x87, 0xed,
	0x46, 0x12, 0x85, 0x96, 0x5a, 0x7b, 0x5d, 0x01, 0x52, 0xa0, 0xbf, 0x13, 0x09, 0x74, 0x0d, 0x53,
	0xe9, 0xe7, 0xab, 0x90, 0x64, 0x91, 0xaa, 0x87, 0x76, 0xd0, 0xdf, 0xa0, 0x77, 0xfe, 0x5f, 0x1e,
	0x3d, 0x0b, 0x09, 0xb9, 0x0b, 0x7d, 0x7c, 0x17, 0xe4, 0x9d, 0xec, 0x9d, 0x14, 0x14, 0x99, 0x18,
	0x15, 0x4e, 0x45, 0xe0, 0x6b, 0xd1, 0x3e, 0xbd, 0x57, 0x72, 0x10, 0xc5, 0xab, 0xbc, 0x05, 0x66,
	0x7d, 0x1d, 0xaa, 0xd0, 0xcd, 0xa0, 0xec, 0xd2, 0x5a, 0xfb, 0xbe, 0x4e, 0x89, 0x9a, 0x19, 0x48,
	0x88, 0x26, 0x9a, 0xc3, 0x1f, 0x9a, 0xbb, 0x98, 0x6a, 0xd5, 0xf8, 0xa7, 0x84, 0x35, 0xd9, 0x88,
	0x4a, 0x4d, 0x89, 0x5b, 0xad, 0x29, 0x3b, 0xa2, 0x28, 0x3c, 0x05, 0xfd, 0x77, 0xe1, 0xfb, 0x65,
	0xd7, 0xa7, 0xac, 0x40, 0x90, 0x8e, 0xa3, 0xa4, 0x06, 0x09, 0xd9, 0x00, 0x1c, 0x9b, 0xec, 0x6d,
	0x5d, 0x7c, 0x16, 0x19, 0xc8, 0x1f, 0x1f, 0x4f, 0x4c, 0x17, 0x5c, 0xba, 0x59, 0xc9, 0xa7, 0xec,
	0xc0, 0x93, 0x43, 0x87, 0xfc, 0x77, 0x99, 0x38, 0x5b, 0x69, 0x5a, 0x2b, 0x61, 0xc2, 0x15, 0xc8,
	0x57, 0x7b, 0xbb, 0x33, 0xc3, 0x45, 0x5c, 0x40, 0x76, 0x2d, 0xc7, 0x86, 0x19, 0x22, 0x2a, 0x97,
	0x34, 0x18, 0x53, 0xb3, 0x14, 0x8d, 0x68, 0x56, 0x65, 0xfc, 0x32, 0x95, 0xb2, 0xdf, 0x1d, 0x3f,
	0x5b, 0x9f, 0xdf, 0x95, 0x4e, 0xf9, 0xb5, 0x60, 0xa2, 0x00, 0x2b, 0x26, 0xdf, 0x18, 0xbc, 0xec,
	0xf1, 0xea, 0xe1, 0x07, 0x9e, 0xaa, 0x10, 0xdd, 0x06, 0xda, 0xad, 0x48, 0xde, 0x17, 0xa1, 0x76,
	0xa1, 0x4e, 0xcd, 0xdf, 0x52, 0xd4, 0x42, 0x43, 0x32, 0xc6, 0x94, 0xd2, 0xbe, 0x28, 0xbb, 0x00,
	0xe7, 0x63, 0xf0, 0x29, 0xfc, 0x4f, 0xe4, 0x29, 0x47, 0x55, 0xcc, 0x8f, 0xe3, 0x61, 0xe6, 0xa3,
	0xb0, 0x68, 0xf7, 0x46, 0x8a, 0xf6, 0x59, 0x48, 0x90, 0x9a, 0x97, 0x0f, 0x8a, 0xb2, 0xaa, 0xc9,
	0x3b, 0x73, 0x92, 0x17, 0x73, 0xbb, 0xec, 0x96, 0x78, 0x31, 0x17, 0xb5, 0x2d, 0xfa, 0x28, 0xac,
	0x7a, 0x09, 0x55, 0xf5, 0x98, 0xe9, 0x4a, 0xd9, 0xcd, 0xf1, 0x81, 0x71, 0x40, 0x98, 0xae, 0x94,
	0xdd, 0x77, 0x10, 0xd9, 0x8c, 0xd9, 0x3a, 0xc5, 0x50, 0x51, 0xff, 0xde, 0x00, 0x90, 0xd1, 0xb9,
	0xb2, 0xb8, 0x7e, 0x04, 0x35, 0x5d, 0x32, 0xe8, 0x8b, 0x67, 0xd0, 0x7f, 0x30, 0x83, 0x11, 0x30,
	0xeb, 0x40, 0x15, 0xfe, 0x7b, 0x1c, 0x3e, 0x0b, 0xc9, 0x23, 0x81, 0x1f, 0x83, 0x48, 0xda, 0x56,
	0x88, 0x7e, 0x93, 0x69, 0x2b, 0xa8, 0xe2, 0xee, 0x8e, 0xf5, 0x75, 0x48, 0xb8, 0x7e, 0xa9, 0x42,
	0x89, 0x3c, 0xd6, 0x56, 0x6c, 0xec, 0x2f, 0x31, 0x91, 0x30, 0xb9, 0x0a, 0x79, 0xf3, 0x0d, 0x18,
	0x08, 0x2a, 0x94, 0xab, 0xf6, 0x72, 0xd5, 0xf3, 0xb1, 0xaa, 0x77, 0xb8, 0x8c, 0xd4, 0x0d, 0x35,
	0xe2, 0x52, 0x56, 0x48, 0x41, 0x71, 0xfb, 0x45, 0x46, 0x4b, 0x50, 0xc5, 0x2b, 0x1b, 0xf4, 0x08,
	0xa2, 0xe5, 0x1a, 0x00, 0x0d, 0x72, 0x48, 0x2c, 0x26, 0x82, 0xa6, 0x55, 0x0a, 0xa1, 0x81, 0x7c,
	0x10, 0x17, 0x39, 0x02, 0x74, 0xc8, 0x65, 0xee, 0xef, 0x11, 0xe8, 0x5d, 0x26, 0x05, 0x33, 0x0f,
	0x09, 0xf9, 0xc9, 0xe6, 0x95, 0xd6, 0xf5, 0x4c, 0x7d, 0x2d, 0xb1, 0xd2, 0x9a, 0x82, 0x6a, 0x8e,
	0xce, 0x43, 0x42, 0x7e, 0x53, 0x69, 0x6f, 0x43, 0x08, 0x6a, 0xd8, 0x68, 0xfc, 0x50, 0x62, 0x52,
	0x18, 0x6e, 0xf8, 0x48, 0x72, 0xb9, 0xed, 0x02, 0x51, 0x71, 0xeb, 0x6a, 0x47, 0xe2, 0xca, 0x6a,
	0x0e, 0xfa, 0xc5, 0x37, 0x8b, 0x97, 0x35, 0xf0, 0xfa, 0x78, 0xdb, 0x4a, 0xe9, 0xc9, 0x29, 0x03,
	0x9b, 0x30, 0xa8, 0x3e, 0x20, 0x5c, 0x6a, 0xab, 0x1b, 0x8a, 0x5a, 0xb3, 0xda, 0xa2, 0xca, 0xd2,
	0x16, 0x24, 0xeb, 0x63, 0xfc, 0x4c, 0x5b, 0x7d, 0x25, 0x6b, 0xcd, 0xe9, 0xcb, 0x46, 0x8d, 0xd5,
	0xa7, 0xf2, 0x19, 0x0d, 0x9f, 0x48, 0x59, 0x0d, 0x63, 0xfb, 0xa6, 0x63, 0xe6, 0x43, 0x35, 0x19,
	0xb7, 0xf7, 0x61, 0x28, 0xaa, 0xe1, 0xc3, 0xe6, 0x41, 0xd7, 0xbc, 0x07, 0x27, 0x9a, 0x86, 0xdc,
	0xb4, 0x4e, 0x5c, 0x45, 0x14, 0xac, 0x6b, 0x1d, 0x2a, 0x34, 0xd9, 0x8e, 0x4e, 0xa8, 0x5a, 0xb6,
	0x23, 0x0a, 0x7a, 0xb6, 0x63, 0x46, 0x4a, 0xf3, 0x33, 0x03, 0x46, 0x62, 0xe7, 0xc9, 0xab, 0x9a,
	0x2b, 0x36, 0xaa, 0x59, 0x37, 0xbb, 0x52, 0x53, 0x70, 0xbe, 0x30, 0xe0, 0xdc, 0x41, 0x93, 0xe2,
	0xf5, 0x4e, 0x96, 0x8e, 0x6a, 0x5a, 0x6f, 0x75, 0xab, 0x79, 0x90, 0x9b, 0xea, 0x03, 0x60, 0x47,
	0x6e, 0x52, 0x6a, 0x9d, 0xb9, 0x69, 0xdf, 0x74, 0xc7, 0x0e, 0x61, 0x7d, 0xb2, 0x9b, 0xd1, 0x59,
	0x4b, 0x7a, 0x62, 0x4e, 0x5f, 0x36, 0x9a, 0x9f, 0x1b, 0xa6, 0xb0, 0xf6, 0xf9, 0x39, 0x2a, 0xae,
	0x91, 0x9f, 0xe3, 0x86, 0x28, 0x46, 0xb1, 0x3e, 0x40, 0xb5, 0xa7, 0xa8, 0x64, 0x35, 0x28, 0xee,
	0x9b, 0x68, 0x98, 0xb1, 0xfa, 0x34, 0xd3, 0xde, 0x98, 0x92, 0xd5, 0x30, 0xb6, 0x6f, 0xe8, 0x30,
	0xef, 0x1b, 0x70, 0x72, 0xdf, 0xc4, 0x31, 0xab, 0x97, 0x3c, 0x22, 0x2a, 0xd6, 0xeb, 0x1d, 0xab,
	0x34, 0xc4, 0x8f, 0x9a, 0x19, 0x34, 0xe2, 0x27, 0x94, 0xd5, 0x89, 0x9f, 0xe6, 0x4e, 0xdd, 0xc4,
	0x30, 0x10, 0x76, 0xe9, 0xd3, 0x5a, 0x7b, 0xb3, 0xb2, 0xb8, 0x6e, 0x5d, 0xd1, 0x95, 0x8c, 0x9a,
	0x09, 0xbb, 0xe9, 0x69, 0xad, 0x5d, 0xd1, 0x33, 0xd3, 0xd4, 0x25, 0xf3, 0xb8, 0x54, 0x1d, 0xb2,
	0x46, 0x5c, 0x86, 0xb2, 0x3a, 0x71, 0xd9, 0xdc, 0xb6, 0x72, 0xd7, 0xc9, 0x96, 0x75, 0x5a, 0x4b,
	0x7d, 0x65, 0x83, 0xea, 0xb8, 0xae, 0xb1, 0xa3, 0xb4, 0xfa, 0xef, 0xef, 0xed, 0xce, 0x18, 0x99,
	0x5b, 0x0f, 0x9f, 0x8e, 0x1b, 0x8f, 0x9e, 0x8e, 0x1b, 0x4f, 0x9e, 0x8e, 0x1b, 0x0f, 0x9e, 0x8d,
	0xf7, 0x3c, 0x7a, 0x36, 0xde, 0xf3, 0xcf, 0xb3, 0xf1, 0x9e, 0xf7, 0x1b, 0x7f, 0x4f, 0xe5, 0x43,
	0xf8, 0x4e, 0xc3, 0xcf, 0x94, 0x7c, 0x00, 0xcf, 0x27, 0xb8, 0xc4, 0xab, 0xff, 0x05, 0x00, 0x00,
	0xff, 0xff, 0xc4, 0x5b, 0xbf, 0xa0, 0x7f, 0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	Commit(ctx context.Context, in *MsgCommit, opts ...grpc.CallOption) (*MsgCommitResponse, error)
	Reveal(ctx context.Context, in *MsgReveal, opts ...grpc.CallOption) (*MsgRevealResponse, error)
	SetValuation(ctx context.Context, in *MsgSetValuation, opts ...grpc.CallOption) (*MsgSetValuationResponse, error)
	Renew(ctx context.Context, in *MsgRenew, opts ...grpc.CallOption) (*MsgRenewResponse, error)
	PlaceBid(ctx context.Context, in *MsgPlaceBid, opts ...grpc.CallOption) (*MsgPlaceBidResponse, error)
	AcceptBid(ctx context.Context, in *MsgAcceptBid, opts ...grpc.CallOption) (*MsgAcceptBidResponse, error)
	RejectBid(ctx context.Context, in *MsgRejectBid, opts ...grpc.CallOption) (*MsgRejectBidResponse, error)
	ClaimBid(ctx context.Context, in *MsgClaimBid, opts ...grpc.CallOption) (*MsgClaimBidResponse, error)
	SetDestination(ctx context.Context, in *MsgSetDestination, opts ...grpc.CallOption) (*MsgSetDestinationResponse, error)
	SetNFTMetadata(ctx context.Context, in *MsgSetNFTMetadata, opts ...grpc.CallOption) (*MsgSetNFTMetadataResponse, error)
	SetNFTClassExtraData(ctx context.Context, in *MsgSetNFTClassExtraData, opts ...grpc.CallOption) (*MsgSetNFTClassExtraDataResponse, error)
	// SetNFTClassAlwaysListed sets the always_listed flag for an NFT class
	SetNFTClassAlwaysListed(ctx context.Context, in *MsgSetNFTClassAlwaysListed, opts ...grpc.CallOption) (*MsgSetNFTClassAlwaysListedResponse, error)
	// SetNFTClassAnnualPct sets the annual percentage rate for an NFT class
	SetNFTClassAnnualPct(ctx context.Context, in *MsgSetNFTClassAnnualPct, opts ...grpc.CallOption) (*MsgSetNFTClassAnnualPctResponse, error)
	// SetListed sets the listed status for a specific NFT
	SetListed(ctx context.Context, in *MsgSetListed, opts ...grpc.CallOption) (*MsgSetListedResponse, error)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	MintCoins(ctx context.Context, in *MsgMintCoins, opts ...grpc.CallOption) (*MsgMintCoinsResponse, error)
	BurnCoins(ctx context.Context, in *MsgBurnCoins, opts ...grpc.CallOption) (*MsgBurnCoinsResponse, error)
	SetDenomMetadata(ctx context.Context, in *MsgSetDenomMetadata, opts ...grpc.CallOption) (*MsgSetDenomMetadataResponse, error)
	SaveClass(ctx context.Context, in *MsgSaveClass, opts ...grpc.CallOption) (*MsgSaveClassResponse, error)
	MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error)
	BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error)
	MoveCoins(ctx context.Context, in *MsgMoveCoins, opts ...grpc.CallOption) (*MsgMoveCoinsResponse, error)
	MoveNft(ctx context.Context, in *MsgMoveNft, opts ...grpc.CallOption) (*MsgMoveNftResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Commit(ctx context.Context, in *MsgCommit, opts ...grpc.CallOption) (*MsgCommitResponse, error) {
	out := new(MsgCommitResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/Commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Reveal(ctx context.Context, in *MsgReveal, opts ...grpc.CallOption) (*MsgRevealResponse, error) {
	out := new(MsgRevealResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/Reveal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetValuation(ctx context.Context, in *MsgSetValuation, opts ...grpc.CallOption) (*MsgSetValuationResponse, error) {
	out := new(MsgSetValuationResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetValuation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Renew(ctx context.Context, in *MsgRenew, opts ...grpc.CallOption) (*MsgRenewResponse, error) {
	out := new(MsgRenewResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/Renew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PlaceBid(ctx context.Context, in *MsgPlaceBid, opts ...grpc.CallOption) (*MsgPlaceBidResponse, error) {
	out := new(MsgPlaceBidResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/PlaceBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AcceptBid(ctx context.Context, in *MsgAcceptBid, opts ...grpc.CallOption) (*MsgAcceptBidResponse, error) {
	out := new(MsgAcceptBidResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/AcceptBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RejectBid(ctx context.Context, in *MsgRejectBid, opts ...grpc.CallOption) (*MsgRejectBidResponse, error) {
	out := new(MsgRejectBidResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/RejectBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimBid(ctx context.Context, in *MsgClaimBid, opts ...grpc.CallOption) (*MsgClaimBidResponse, error) {
	out := new(MsgClaimBidResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/ClaimBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDestination(ctx context.Context, in *MsgSetDestination, opts ...grpc.CallOption) (*MsgSetDestinationResponse, error) {
	out := new(MsgSetDestinationResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetDestination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTMetadata(ctx context.Context, in *MsgSetNFTMetadata, opts ...grpc.CallOption) (*MsgSetNFTMetadataResponse, error) {
	out := new(MsgSetNFTMetadataResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetNFTMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTClassExtraData(ctx context.Context, in *MsgSetNFTClassExtraData, opts ...grpc.CallOption) (*MsgSetNFTClassExtraDataResponse, error) {
	out := new(MsgSetNFTClassExtraDataResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetNFTClassExtraData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTClassAlwaysListed(ctx context.Context, in *MsgSetNFTClassAlwaysListed, opts ...grpc.CallOption) (*MsgSetNFTClassAlwaysListedResponse, error) {
	out := new(MsgSetNFTClassAlwaysListedResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetNFTClassAlwaysListed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTClassAnnualPct(ctx context.Context, in *MsgSetNFTClassAnnualPct, opts ...grpc.CallOption) (*MsgSetNFTClassAnnualPctResponse, error) {
	out := new(MsgSetNFTClassAnnualPctResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetNFTClassAnnualPct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetListed(ctx context.Context, in *MsgSetListed, opts ...grpc.CallOption) (*MsgSetListedResponse, error) {
	out := new(MsgSetListedResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetListed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintCoins(ctx context.Context, in *MsgMintCoins, opts ...grpc.CallOption) (*MsgMintCoinsResponse, error) {
	out := new(MsgMintCoinsResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/MintCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnCoins(ctx context.Context, in *MsgBurnCoins, opts ...grpc.CallOption) (*MsgBurnCoinsResponse, error) {
	out := new(MsgBurnCoinsResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/BurnCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDenomMetadata(ctx context.Context, in *MsgSetDenomMetadata, opts ...grpc.CallOption) (*MsgSetDenomMetadataResponse, error) {
	out := new(MsgSetDenomMetadataResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SetDenomMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SaveClass(ctx context.Context, in *MsgSaveClass, opts ...grpc.CallOption) (*MsgSaveClassResponse, error) {
	out := new(MsgSaveClassResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/SaveClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error) {
	out := new(MsgMintNFTResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/MintNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error) {
	out := new(MsgBurnNFTResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/BurnNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MoveCoins(ctx context.Context, in *MsgMoveCoins, opts ...grpc.CallOption) (*MsgMoveCoinsResponse, error) {
	out := new(MsgMoveCoinsResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/MoveCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MoveNft(ctx context.Context, in *MsgMoveNft, opts ...grpc.CallOption) (*MsgMoveNftResponse, error) {
	out := new(MsgMoveNftResponse)
	err := c.cc.Invoke(ctx, "/dysonprotocol.nameservice.v1.Msg/MoveNft", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	Commit(context.Context, *MsgCommit) (*MsgCommitResponse, error)
	Reveal(context.Context, *MsgReveal) (*MsgRevealResponse, error)
	SetValuation(context.Context, *MsgSetValuation) (*MsgSetValuationResponse, error)
	Renew(context.Context, *MsgRenew) (*MsgRenewResponse, error)
	PlaceBid(context.Context, *MsgPlaceBid) (*MsgPlaceBidResponse, error)
	AcceptBid(context.Context, *MsgAcceptBid) (*MsgAcceptBidResponse, error)
	RejectBid(context.Context, *MsgRejectBid) (*MsgRejectBidResponse, error)
	ClaimBid(context.Context, *MsgClaimBid) (*MsgClaimBidResponse, error)
	SetDestination(context.Context, *MsgSetDestination) (*MsgSetDestinationResponse, error)
	SetNFTMetadata(context.Context, *MsgSetNFTMetadata) (*MsgSetNFTMetadataResponse, error)
	SetNFTClassExtraData(context.Context, *MsgSetNFTClassExtraData) (*MsgSetNFTClassExtraDataResponse, error)
	// SetNFTClassAlwaysListed sets the always_listed flag for an NFT class
	SetNFTClassAlwaysListed(context.Context, *MsgSetNFTClassAlwaysListed) (*MsgSetNFTClassAlwaysListedResponse, error)
	// SetNFTClassAnnualPct sets the annual percentage rate for an NFT class
	SetNFTClassAnnualPct(context.Context, *MsgSetNFTClassAnnualPct) (*MsgSetNFTClassAnnualPctResponse, error)
	// SetListed sets the listed status for a specific NFT
	SetListed(context.Context, *MsgSetListed) (*MsgSetListedResponse, error)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	MintCoins(context.Context, *MsgMintCoins) (*MsgMintCoinsResponse, error)
	BurnCoins(context.Context, *MsgBurnCoins) (*MsgBurnCoinsResponse, error)
	SetDenomMetadata(context.Context, *MsgSetDenomMetadata) (*MsgSetDenomMetadataResponse, error)
	SaveClass(context.Context, *MsgSaveClass) (*MsgSaveClassResponse, error)
	MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error)
	BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error)
	MoveCoins(context.Context, *MsgMoveCoins) (*MsgMoveCoinsResponse, error)
	MoveNft(context.Context, *MsgMoveNft) (*MsgMoveNftResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Commit(ctx context.Context, req *MsgCommit) (*MsgCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (*UnimplementedMsgServer) Reveal(ctx context.Context, req *MsgReveal) (*MsgRevealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reveal not implemented")
}
func (*UnimplementedMsgServer) SetValuation(ctx context.Context, req *MsgSetValuation) (*MsgSetValuationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetValuation not implemented")
}
func (*UnimplementedMsgServer) Renew(ctx context.Context, req *MsgRenew) (*MsgRenewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Renew not implemented")
}
func (*UnimplementedMsgServer) PlaceBid(ctx context.Context, req *MsgPlaceBid) (*MsgPlaceBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceBid not implemented")
}
func (*UnimplementedMsgServer) AcceptBid(ctx context.Context, req *MsgAcceptBid) (*MsgAcceptBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptBid not implemented")
}
func (*UnimplementedMsgServer) RejectBid(ctx context.Context, req *MsgRejectBid) (*MsgRejectBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectBid not implemented")
}
func (*UnimplementedMsgServer) ClaimBid(ctx context.Context, req *MsgClaimBid) (*MsgClaimBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimBid not implemented")
}
func (*UnimplementedMsgServer) SetDestination(ctx context.Context, req *MsgSetDestination) (*MsgSetDestinationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDestination not implemented")
}
func (*UnimplementedMsgServer) SetNFTMetadata(ctx context.Context, req *MsgSetNFTMetadata) (*MsgSetNFTMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTMetadata not implemented")
}
func (*UnimplementedMsgServer) SetNFTClassExtraData(ctx context.Context, req *MsgSetNFTClassExtraData) (*MsgSetNFTClassExtraDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTClassExtraData not implemented")
}
func (*UnimplementedMsgServer) SetNFTClassAlwaysListed(ctx context.Context, req *MsgSetNFTClassAlwaysListed) (*MsgSetNFTClassAlwaysListedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTClassAlwaysListed not implemented")
}
func (*UnimplementedMsgServer) SetNFTClassAnnualPct(ctx context.Context, req *MsgSetNFTClassAnnualPct) (*MsgSetNFTClassAnnualPctResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTClassAnnualPct not implemented")
}
func (*UnimplementedMsgServer) SetListed(ctx context.Context, req *MsgSetListed) (*MsgSetListedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetListed not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) MintCoins(ctx context.Context, req *MsgMintCoins) (*MsgMintCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintCoins not implemented")
}
func (*UnimplementedMsgServer) BurnCoins(ctx context.Context, req *MsgBurnCoins) (*MsgBurnCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnCoins not implemented")
}
func (*UnimplementedMsgServer) SetDenomMetadata(ctx context.Context, req *MsgSetDenomMetadata) (*MsgSetDenomMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDenomMetadata not implemented")
}
func (*UnimplementedMsgServer) SaveClass(ctx context.Context, req *MsgSaveClass) (*MsgSaveClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveClass not implemented")
}
func (*UnimplementedMsgServer) MintNFT(ctx context.Context, req *MsgMintNFT) (*MsgMintNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (*UnimplementedMsgServer) BurnNFT(ctx context.Context, req *MsgBurnNFT) (*MsgBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFT not implemented")
}
func (*UnimplementedMsgServer) MoveCoins(ctx context.Context, req *MsgMoveCoins) (*MsgMoveCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveCoins not implemented")
}
func (*UnimplementedMsgServer) MoveNft(ctx context.Context, req *MsgMoveNft) (*MsgMoveNftResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveNft not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Commit(ctx, req.(*MsgCommit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Reveal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReveal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Reveal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/Reveal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Reveal(ctx, req.(*MsgReveal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetValuation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetValuation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetValuation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetValuation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetValuation(ctx, req.(*MsgSetValuation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Renew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRenew)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Renew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/Renew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Renew(ctx, req.(*MsgRenew))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PlaceBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPlaceBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PlaceBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/PlaceBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PlaceBid(ctx, req.(*MsgPlaceBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AcceptBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAcceptBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AcceptBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/AcceptBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AcceptBid(ctx, req.(*MsgAcceptBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RejectBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRejectBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RejectBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/RejectBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RejectBid(ctx, req.(*MsgRejectBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/ClaimBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimBid(ctx, req.(*MsgClaimBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDestination(ctx, req.(*MsgSetDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetNFTMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTMetadata(ctx, req.(*MsgSetNFTMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTClassExtraData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTClassExtraData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTClassExtraData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetNFTClassExtraData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTClassExtraData(ctx, req.(*MsgSetNFTClassExtraData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTClassAlwaysListed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTClassAlwaysListed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTClassAlwaysListed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetNFTClassAlwaysListed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTClassAlwaysListed(ctx, req.(*MsgSetNFTClassAlwaysListed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTClassAnnualPct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTClassAnnualPct)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTClassAnnualPct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetNFTClassAnnualPct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTClassAnnualPct(ctx, req.(*MsgSetNFTClassAnnualPct))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetListed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetListed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetListed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetListed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetListed(ctx, req.(*MsgSetListed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/MintCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintCoins(ctx, req.(*MsgMintCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/BurnCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnCoins(ctx, req.(*MsgBurnCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDenomMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDenomMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDenomMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SetDenomMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDenomMetadata(ctx, req.(*MsgSetDenomMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SaveClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSaveClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SaveClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/SaveClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SaveClass(ctx, req.(*MsgSaveClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/MintNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNFT(ctx, req.(*MsgMintNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/BurnNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFT(ctx, req.(*MsgBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MoveCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMoveCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MoveCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/MoveCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MoveCoins(ctx, req.(*MsgMoveCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MoveNft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMoveNft)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MoveNft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dysonprotocol.nameservice.v1.Msg/MoveNft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MoveNft(ctx, req.(*MsgMoveNft))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dysonprotocol.nameservice.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Commit",
			Handler:    _Msg_Commit_Handler,
		},
		{
			MethodName: "Reveal",
			Handler:    _Msg_Reveal_Handler,
		},
		{
			MethodName: "SetValuation",
			Handler:    _Msg_SetValuation_Handler,
		},
		{
			MethodName: "Renew",
			Handler:    _Msg_Renew_Handler,
		},
		{
			MethodName: "PlaceBid",
			Handler:    _Msg_PlaceBid_Handler,
		},
		{
			MethodName: "AcceptBid",
			Handler:    _Msg_AcceptBid_Handler,
		},
		{
			MethodName: "RejectBid",
			Handler:    _Msg_RejectBid_Handler,
		},
		{
			MethodName: "ClaimBid",
			Handler:    _Msg_ClaimBid_Handler,
		},
		{
			MethodName: "SetDestination",
			Handler:    _Msg_SetDestination_Handler,
		},
		{
			MethodName: "SetNFTMetadata",
			Handler:    _Msg_SetNFTMetadata_Handler,
		},
		{
			MethodName: "SetNFTClassExtraData",
			Handler:    _Msg_SetNFTClassExtraData_Handler,
		},
		{
			MethodName: "SetNFTClassAlwaysListed",
			Handler:    _Msg_SetNFTClassAlwaysListed_Handler,
		},
		{
			MethodName: "SetNFTClassAnnualPct",
			Handler:    _Msg_SetNFTClassAnnualPct_Handler,
		},
		{
			MethodName: "SetListed",
			Handler:    _Msg_SetListed_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "MintCoins",
			Handler:    _Msg_MintCoins_Handler,
		},
		{
			MethodName: "BurnCoins",
			Handler:    _Msg_BurnCoins_Handler,
		},
		{
			MethodName: "SetDenomMetadata",
			Handler:    _Msg_SetDenomMetadata_Handler,
		},
		{
			MethodName: "SaveClass",
			Handler:    _Msg_SaveClass_Handler,
		},
		{
			MethodName: "MintNFT",
			Handler:    _Msg_MintNFT_Handler,
		},
		{
			MethodName: "BurnNFT",
			Handler:    _Msg_BurnNFT_Handler,
		},
		{
			MethodName: "MoveCoins",
			Handler:    _Msg_MoveCoins_Handler,
		},
		{
			MethodName: "MoveNft",
			Handler:    _Msg_MoveNft_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dysonprotocol/nameservice/v1/tx.proto",
}

func (m *MsgCommit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Valuation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Hexhash) > 0 {
		i -= len(m.Hexhash)
		copy(dAtA[i:], m.Hexhash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Hexhash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Committer) > 0 {
		i -= len(m.Committer)
		copy(dAtA[i:], m.Committer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Committer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCommitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgReveal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReveal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReveal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Committer) > 0 {
		i -= len(m.Committer)
		copy(dAtA[i:], m.Committer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Committer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetValuation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetValuation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetValuation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Valuation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetValuationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetValuationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetValuationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRenew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRenew) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRenew) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payer) > 0 {
		i -= len(m.Payer)
		copy(dAtA[i:], m.Payer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Payer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRenewResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRenewResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRenewResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Expiry, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Expiry):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintTx(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPlaceBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BidAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPlaceBidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceBidResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceBidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAcceptBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAcceptBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAcceptBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAcceptBidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAcceptBidResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAcceptBidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRejectBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRejectBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRejectBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NewValuation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRejectBidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRejectBidResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRejectBidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimBidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimBidResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimBidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetDestinationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDestinationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDestinationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTClassExtraData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTClassExtraData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTClassExtraData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtraData) > 0 {
		i -= len(m.ExtraData)
		copy(dAtA[i:], m.ExtraData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExtraData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTClassExtraDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTClassExtraDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTClassExtraDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTClassAlwaysListed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTClassAlwaysListed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTClassAlwaysListed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlwaysListed {
		i--
		if m.AlwaysListed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTClassAlwaysListedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTClassAlwaysListedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTClassAlwaysListedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTClassAnnualPct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTClassAnnualPct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTClassAnnualPct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AnnualPct) > 0 {
		i -= len(m.AnnualPct)
		copy(dAtA[i:], m.AnnualPct)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AnnualPct)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetNFTClassAnnualPctResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetNFTClassAnnualPctResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetNFTClassAnnualPctResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetListed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetListed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetListed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Listed {
		i--
		if m.Listed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftClassId) > 0 {
		i -= len(m.NftClassId)
		copy(dAtA[i:], m.NftClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftOwner) > 0 {
		i -= len(m.NftOwner)
		copy(dAtA[i:], m.NftOwner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftOwner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetListedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetListedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetListedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMintCoins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintCoins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintCoins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintCoinsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintCoinsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintCoinsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnCoins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnCoins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnCoins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnCoinsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnCoinsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnCoinsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetDenomMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDenomMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDenomMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetDenomMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDenomMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDenomMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSaveClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSaveClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSaveClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UriHash) > 0 {
		i -= len(m.UriHash)
		copy(dAtA[i:], m.UriHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UriHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSaveClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSaveClassResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSaveClassResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMintNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UriHash) > 0 {
		i -= len(m.UriHash)
		copy(dAtA[i:], m.UriHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UriHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMoveCoins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMoveCoins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMoveCoins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMoveCoinsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMoveCoinsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMoveCoinsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMoveNft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMoveNft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMoveNft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMoveNftResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMoveNftResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMoveNftResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Committer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Hexhash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Valuation.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCommitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgReveal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Committer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetValuation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Valuation.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetValuationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRenew) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRenewResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Expiry)
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPlaceBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BidAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPlaceBidResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAcceptBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAcceptBidResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRejectBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.NewValuation.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRejectBidResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimBidResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetDestinationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetNFTMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetNFTMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetNFTClassExtraData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ExtraData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetNFTClassExtraDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetNFTClassAlwaysListed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.AlwaysListed {
		n += 2
	}
	return n
}

func (m *MsgSetNFTClassAlwaysListedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetNFTClassAnnualPct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AnnualPct)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetNFTClassAnnualPctResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetListed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftOwner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Listed {
		n += 2
	}
	return n
}

func (m *MsgSetListedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgMintCoins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgMintCoinsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnCoins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBurnCoinsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetDenomMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetDenomMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSaveClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UriHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSaveClassResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgMintNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UriHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBurnNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgMoveCoins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgMoveCoinsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgMoveNft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMoveNftResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Committer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hexhash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hexhash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valuation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Valuation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReveal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReveal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReveal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Committer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetValuation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetValuation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetValuation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valuation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Valuation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetValuationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetValuationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetValuationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRenew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRenew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRenew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRenewResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRenewResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRenewResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Expiry, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceBidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceBidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceBidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAcceptBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAcceptBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAcceptBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAcceptBidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAcceptBidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAcceptBidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRejectBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRejectBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRejectBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValuation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewValuation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRejectBidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRejectBidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRejectBidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimBidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimBidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimBidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDestinationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDestinationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDestinationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTClassExtraData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTClassExtraData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTClassExtraData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTClassExtraDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTClassExtraDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTClassExtraDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTClassAlwaysListed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTClassAlwaysListed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTClassAlwaysListed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysListed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysListed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTClassAlwaysListedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTClassAlwaysListedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTClassAlwaysListedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTClassAnnualPct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTClassAnnualPct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTClassAnnualPct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnualPct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnualPct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetNFTClassAnnualPctResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetNFTClassAnnualPctResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetNFTClassAnnualPctResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetListed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetListed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetListed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Listed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetListedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetListedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetListedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintCoins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintCoins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintCoins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintCoinsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintCoinsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintCoinsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnCoins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnCoins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnCoins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnCoinsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnCoinsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnCoinsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDenomMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDenomMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDenomMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDenomMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDenomMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDenomMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSaveClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSaveClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSaveClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSaveClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSaveClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSaveClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMoveCoins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMoveCoins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMoveCoins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, types1.Input{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, types1.Output{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMoveCoinsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMoveCoinsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMoveCoinsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMoveNft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMoveNft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMoveNft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMoveNftResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMoveNftResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMoveNftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
