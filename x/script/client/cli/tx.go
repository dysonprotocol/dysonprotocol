package cli

import (
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/spf13/cobra"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/client/tx"
	"github.com/cosmos/cosmos-sdk/codec/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	authztypes "github.com/cosmos/cosmos-sdk/x/authz"

	scripttypes "dysonprotocol.com/x/script/types"
)

// NewTxCmd returns a root CLI command handler for all x/script transaction commands.
func NewTxCmd() *cobra.Command {
	txCmd := &cobra.Command{
		Use:                        "script",
		Short:                      "Script subcommands",
		DisableFlagParsing:         true,
		SuggestionsMinimumDistance: 2,
		RunE:                       client.ValidateCmd,
	}

	txCmd.AddCommand(NewUpdateScriptCmd())
	txCmd.AddCommand(NewCreateNewScriptCmd())
	txCmd.AddCommand(NewExecScriptCmd())
	txCmd.AddCommand(CmdGrantExecAuthorization())

	return txCmd
}

// NewUpdateScriptCmd returns the CLI command handler for updating a script.
func NewUpdateScriptCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "update [--code <code> | --code-path <path to source code>]",
		Short: "Updates the script at the sender's address with new code and increments the version",
		Long: `Updates the script at the sender's address (--from) with new code and increments the version.
If no script exists at the sender's address, a new script will be created.
You must provide either --code or --code-path but not both.
An empty code string (--code "") is allowed.

Examples:
  # Update using a file
  $ dysond tx script update --code-path ./my_script.py --from myaccount

  # Update using inline code
  $ dysond tx script update --code "def main(): return 'hello world'" --from myaccount
  
  # Update with empty code
  $ dysond tx script update --code "" --from myaccount`,
		RunE: func(cmd *cobra.Command, args []string) error {
			clientCtx, err := client.GetClientTxContext(cmd)
			if err != nil {
				return err
			}

			// Check which flags are explicitly set
			codeProvided := cmd.Flags().Changed("code")
			codePathProvided := cmd.Flags().Changed("code-path")

			// Validate both are not provided
			if codeProvided && codePathProvided {
				return errors.New("cannot provide both --code and --code-path, use only one")
			}

			// Validate at least one is provided
			if !codeProvided && !codePathProvided {
				return errors.New("either --code or --code-path must be provided")
			}

			// Get code content based on which flag was used
			var codeContent string
			if codeProvided {
				code, err := cmd.Flags().GetString("code")
				if err != nil {
					return err
				}
				codeContent = code // This can be empty, which is allowed
			} else {
				codePath, err := cmd.Flags().GetString("code-path")
				if err != nil {
					return err
				}
				// Read file contents
				codeBytes, err := os.ReadFile(codePath)
				if err != nil {
					return fmt.Errorf("failed to read file %s: %w", codePath, err)
				}
				codeContent = string(codeBytes)
			}

			// Use the sender address as the script address
			scriptAddress := clientCtx.GetFromAddress().String()

			msg := &scripttypes.MsgUpdateScript{
				Address: scriptAddress,
				Code:    codeContent,
			}

			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
		},
	}

	cmd.Flags().String("code", "", "Source code as a string")
	cmd.Flags().String("code-path", "", "Path to the source code file")

	flags.AddTxFlagsToCmd(cmd)

	return cmd
}

func NewCreateNewScriptCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "create-new-script",
		Short: "Creates a new script with a deterministic address derived from creator and code",
		Long: `Creates a new script with the provided code at a deterministic address.
The script address is generated by hashing the creator's address and the script code.
This creates a brand new address that does not have a private key - it can only be controlled through script execution.

An authz grant is automatically created that allows the creator (--from address) to update the script later.
This means you can use 'dysond tx script update' to modify the script code even though you don't own the script's private key.

You must provide either --code or --code-path but not both.
An empty code string (--code "") is allowed.

Examples:
  # Create using a file
  $ dysond tx script create-new-script --code-path ./my_script.py --from myaccount

  # Create using inline code
  $ dysond tx script create-new-script --code "def main(): return 'hello world'" --from myaccount
  
  # Create with empty code
  $ dysond tx script create-new-script --code "" --from myaccount`,
		RunE: func(cmd *cobra.Command, args []string) error {
			clientCtx, err := client.GetClientTxContext(cmd)
			if err != nil {
				return err
			}

			// Check which flags are explicitly set
			codeProvided := cmd.Flags().Changed("code")
			codePathProvided := cmd.Flags().Changed("code-path")

			// Validate both are not provided
			if codeProvided && codePathProvided {
				return errors.New("cannot provide both --code and --code-path, use only one")
			}

			// Validate at least one is provided
			if !codeProvided && !codePathProvided {
				return errors.New("either --code or --code-path must be provided")
			}

			// Get code content based on which flag was used
			var codeContent string
			if codeProvided {
				code, err := cmd.Flags().GetString("code")
				if err != nil {
					return err
				}
				codeContent = code // This can be empty, which is allowed
			} else {
				codePath, err := cmd.Flags().GetString("code-path")
				if err != nil {
					return err
				}
				// Read file contents
				codeBytes, err := os.ReadFile(codePath)
				if err != nil {
					return fmt.Errorf("failed to read file %s: %w", codePath, err)
				}
				codeContent = string(codeBytes)
			}

			msg := &scripttypes.MsgCreateNewScript{
				CreatorAddress: clientCtx.GetFromAddress().String(),
				Code:           codeContent,
			}

			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
		},
	}

	cmd.Flags().String("code", "", "Source code as a string")
	cmd.Flags().String("code-path", "", "Path to the source code file")

	flags.AddTxFlagsToCmd(cmd)

	return cmd
}

func NewExecScriptCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "exec --script-address <script_address> [--args <input_data>] [--function-name <function_name>] [--extra-code <extra_code>] [--kwargs <keyword_args>] [--attached-message <message>]",
		Short: "Executes a script at a given address with optional input data and parameters",
		Long: `Executes a script at a given address with optional input data and other parameters.

Required Flags:
  --script-address: The address of the script to execute (can be a bech32 address or a nameservice name like 'example.dys')

Optional Flags:
  --args: Positional arguments to pass to the function as a JSON list (e.g., '["arg1", "arg2"]')
  --function-name: The name of the function to run (defaults to a main or entry point function if not specified)
  --extra-code: Additional code to temporarily append to the script for this execution (only allowed if the executor is the owner of the script)
  --kwargs: Keyword arguments to pass to the function as a JSON dictionary (e.g., '{"key1": "value1", "key2": "value2"}')
  --attached-message: Attached message to include in the transaction as JSON (can be used multiple times)

Examples:
  # Execute a script with minimal parameters
  $ dysond tx script exec --script-address dys123...

  # Execute a script with input data as positional arguments
  $ dysond tx script exec --script-address dys123... --args '["arg1", "arg2"]'

  # Execute a script with a specific function name and keyword arguments
  $ dysond tx script exec --script-address dys123... --function-name "process_data" --kwargs '{"input_type": "json", "verbose": true}'

  # Execute a script with extra code (if executor is the owner)
  $ dysond tx script exec --script-address dys123... --extra-code "def helper(): return 'temp help';"

  # Execute a script with attached messages
  $ dysond tx script exec --script-address dys123... --attached-message '{"@type":"/cosmos.bank.v1beta1.MsgSend","from_address":"dys123...","to_address":"dys456...","amount":[{"denom":"dys","amount":"100"}]}' --attached-message '{"@type":"/cosmos.bank.v1beta1.MsgSend","from_address":"dys123...","to_address":"dys789...","amount":[{"denom":"dys","amount":"200"}]}'`,
		RunE: func(cmd *cobra.Command, args []string) error {
			clientCtx, err := client.GetClientTxContext(cmd)
			if err != nil {
				return err
			}

			scriptAddress, err := cmd.Flags().GetString("script-address")
			if err != nil {
				return err
			}

			if scriptAddress == "" {
				return errors.New("--script-address flag is required")
			}

			inputData, err := cmd.Flags().GetString("args")
			if err != nil {
				return err
			}

			functionName, err := cmd.Flags().GetString("function-name")
			if err != nil {
				return err
			}

			extraCode, err := cmd.Flags().GetString("extra-code")
			if err != nil {
				return err
			}

			kwargs, err := cmd.Flags().GetString("kwargs")
			if err != nil {
				return err
			}

			// Parse attached messages
			attachedMessageStrings, err := cmd.Flags().GetStringArray("attached-message")
			if err != nil {
				return err
			}

			var attachedMessages []*types.Any
			for _, msgStr := range attachedMessageStrings {
				if msgStr == "" {
					continue
				}

				// Parse and encode the JSON message properly
				var msg sdk.Msg
				err := clientCtx.Codec.UnmarshalInterfaceJSON([]byte(msgStr), &msg)
				if err != nil {
					return fmt.Errorf("failed to unmarshal attached message JSON: %w", err)
				}

				// Create the Any message with properly encoded protobuf
				anyMsg, err := types.NewAnyWithValue(msg)
				if err != nil {
					return fmt.Errorf("failed to create Any message: %w", err)
				}

				attachedMessages = append(attachedMessages, anyMsg)
			}

			msg := &scripttypes.MsgExec{
				ExecutorAddress:  clientCtx.GetFromAddress().String(),
				ScriptAddress:    scriptAddress,
				Args:             inputData,
				FunctionName:     functionName,
				ExtraCode:        extraCode,
				Kwargs:           kwargs,
				AttachedMessages: attachedMessages,
			}

			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
		},
	}

	cmd.Flags().String("script-address", "", "Address of the script to execute (required)")
	cmd.Flags().String("args", "", "Input data for the script execution as positional arguments (JSON list)")
	cmd.Flags().String("function-name", "", "Name of the function to execute")
	cmd.Flags().String("extra-code", "", "Extra code to temporarily append to the script (only if executor is owner)")
	cmd.Flags().String("kwargs", "", "Keyword arguments for the script execution (JSON dictionary)")
	cmd.Flags().StringArray("attached-message", []string{}, "Attached message to include in the transaction as JSON (can be used multiple times)")

	flags.AddTxFlagsToCmd(cmd)

	return cmd
}

// CmdGrantExecAuthorization returns a command to grant ExecAuthorization to a grantee.
func CmdGrantExecAuthorization() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "grant-exec [grantee-address]",
		Short: "Grant a custom ExecAuthorization to a grantee (via authz)",
		Long: `Creates an Authz grant of type ExecAuthorization, allowing the grantee
to execute a specific script (and optionally specific functions within it). 

Examples:
  # Grant permission to execute specific functions
  $ dysond tx script grant-exec <grantee-addr> \
    --script-address=<scriptAddr> \
    --function-names=init,update \
    --expiration="2025-06-30T12:00:00Z" \
    --from=<granter-key-or-address>

  # Grant permission to execute script directly (no function names)
  $ dysond tx script grant-exec <grantee-addr> \
    --script-address=<scriptAddr> \
    --expiration="2025-06-30T12:00:00Z" \
    --from=<granter-key-or-address>`,
		Args: cobra.ExactArgs(1), // only one positional: grantee-address
		RunE: func(cmd *cobra.Command, args []string) error {
			// 1. Get client context (contains the granter's address, keyring, etc.)
			clientCtx, err := client.GetClientTxContext(cmd)
			if err != nil {
				return err
			}
			granterAddr := clientCtx.GetFromAddress() // from `--from`

			// 2. Parse grantee address (positional arg)
			granteeAddr := args[0]
			if _, err := sdk.AccAddressFromBech32(granteeAddr); err != nil {
				return fmt.Errorf("invalid grantee address: %w", err)
			}

			// 3. Read & validate --script-address
			scriptAddrStr, err := cmd.Flags().GetString("script-address")
			if err != nil {
				return err
			}
			if scriptAddrStr == "" {
				return fmt.Errorf("--script-address must be provided")
			}
			if _, err := sdk.AccAddressFromBech32(scriptAddrStr); err != nil {
				return fmt.Errorf("invalid script address: %w", err)
			}

			// 4. Read --function-names (string slice, optional)
			fnames, err := cmd.Flags().GetStringSlice("function-names")
			if err != nil {
				return err
			}
			// fnames may be empty => only script entrypoint is allowed

			// 5. Parse & validate --expiration (RFC3339)
			expStr, err := cmd.Flags().GetString("expiration")
			if err != nil {
				return err
			}
			if expStr == "" {
				return fmt.Errorf("--expiration must be provided (RFC3339)")
			}
			expTime, err := time.Parse(time.RFC3339, expStr)
			if err != nil {
				return fmt.Errorf("parsing expiration as RFC3339 failed: %w", err)
			}
			// Convert to UTC and into Timestamp
			ts := timestamppb.New(expTime.UTC())
			if err := ts.CheckValid(); err != nil {
				return fmt.Errorf("expiration timestamp invalid: %w", err)
			}

			// 6. Construct custom ExecAuthorization
			customAuth := &scripttypes.ExecAuthorization{
				ScriptAddress: scriptAddrStr,
				FunctionNames: fnames,
			}

			// 7. Wrap in MsgGrant
			expTimeValue := ts.AsTime()
			msg, err := authztypes.NewMsgGrant(
				granterAddr,
				sdk.MustAccAddressFromBech32(granteeAddr),
				customAuth,
				&expTimeValue,
			)
			if err != nil {
				return fmt.Errorf("failed to create MsgGrant: %w", err)
			}

			// 8. Broadcast transaction via standard SDK machinery
			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
		},
	}

	// 9. Define flags
	cmd.Flags().String("script-address", "", "Bech32 address of the script to authorize (required)")
	cmd.Flags().StringSlice("function-names", []string{}, "Comma-separated list of function names allowed (optional)")
	cmd.Flags().String("expiration", "", "Expiration time as RFC3339 timestamp (e.g. 2025-06-30T12:00:00Z) (required)")

	// Mark required flags
	_ = cmd.MarkFlagRequired("script-address")
	_ = cmd.MarkFlagRequired("expiration")

	// Add other tx flags (chain-id, broadcast-mode, etc.)
	flags.AddTxFlagsToCmd(cmd)
	return cmd
}
