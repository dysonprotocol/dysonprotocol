// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dysonprotocol/crontask/v1/crontask.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/cosmos-sdk/x/bank/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	any "github.com/cosmos/gogoproto/types/any"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Task represents a scheduled task in the crontask system
type Task struct {
	// The unique identifier for the task
	TaskId uint64 `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// Address of the creator of the task
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
	// Unix timestamp when the task is scheduled to execute
	ScheduledTimestamp int64 `protobuf:"varint,3,opt,name=scheduled_timestamp,json=scheduledTimestamp,proto3" json:"scheduled_timestamp,omitempty"`
	// Unix timestamp after which the task will expire if not executed
	ExpiryTimestamp int64 `protobuf:"varint,4,opt,name=expiry_timestamp,json=expiryTimestamp,proto3" json:"expiry_timestamp,omitempty"`
	// Maximum gas limit for the task execution
	TaskGasLimit uint64 `protobuf:"varint,5,opt,name=task_gas_limit,json=taskGasLimit,proto3" json:"task_gas_limit,omitempty"`
	// Gas price for the task execution which is calculated automatically
	// from task_gas_fee / task_gas_limit
	TaskGasPrice types.Coin `protobuf:"bytes,6,opt,name=task_gas_price,json=taskGasPrice,proto3" json:"task_gas_price"`
	// Gas fee for the task execution
	TaskGasFee types.Coin `protobuf:"bytes,7,opt,name=task_gas_fee,json=taskGasFee,proto3" json:"task_gas_fee"`
	// Messages to execute as part of the task
	Msgs []*any.Any `protobuf:"bytes,8,rep,name=msgs,proto3" json:"msgs,omitempty"`
	// Results of message execution
	MsgResults []*any.Any `protobuf:"bytes,9,rep,name=msg_results,json=msgResults,proto3" json:"msg_results,omitempty"`
	// Current status of the task: Scheduled, Done, Failed, Expired
	Status string `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	// Block timestamp when the task was created
	CreationTime int64 `protobuf:"varint,11,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// Error message if task execution failed
	ErrorLog string `protobuf:"bytes,12,opt,name=error_log,json=errorLog,proto3" json:"error_log,omitempty"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_c2a40f3e0e41e1b8, []int{0}
}
func (m *Task) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Task.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return m.Size()
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *Task) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Task) GetScheduledTimestamp() int64 {
	if m != nil {
		return m.ScheduledTimestamp
	}
	return 0
}

func (m *Task) GetExpiryTimestamp() int64 {
	if m != nil {
		return m.ExpiryTimestamp
	}
	return 0
}

func (m *Task) GetTaskGasLimit() uint64 {
	if m != nil {
		return m.TaskGasLimit
	}
	return 0
}

func (m *Task) GetTaskGasPrice() types.Coin {
	if m != nil {
		return m.TaskGasPrice
	}
	return types.Coin{}
}

func (m *Task) GetTaskGasFee() types.Coin {
	if m != nil {
		return m.TaskGasFee
	}
	return types.Coin{}
}

func (m *Task) GetMsgs() []*any.Any {
	if m != nil {
		return m.Msgs
	}
	return nil
}

func (m *Task) GetMsgResults() []*any.Any {
	if m != nil {
		return m.MsgResults
	}
	return nil
}

func (m *Task) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Task) GetCreationTime() int64 {
	if m != nil {
		return m.CreationTime
	}
	return 0
}

func (m *Task) GetErrorLog() string {
	if m != nil {
		return m.ErrorLog
	}
	return ""
}

// Params defines the parameters for the crontask module
type Params struct {
	// Maximum gas allowed for executing tasks per block
	BlockGasLimit uint64 `protobuf:"varint,1,opt,name=block_gas_limit,json=blockGasLimit,proto3" json:"block_gas_limit,omitempty"`
	// Default expiry limit in seconds (24 hours)
	ExpiryLimit int64 `protobuf:"varint,2,opt,name=expiry_limit,json=expiryLimit,proto3" json:"expiry_limit,omitempty"`
	// Maximum allowed scheduled time in seconds from task creation (24 hours)
	MaxScheduledTime int64 `protobuf:"varint,3,opt,name=max_scheduled_time,json=maxScheduledTime,proto3" json:"max_scheduled_time,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_c2a40f3e0e41e1b8, []int{1}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetBlockGasLimit() uint64 {
	if m != nil {
		return m.BlockGasLimit
	}
	return 0
}

func (m *Params) GetExpiryLimit() int64 {
	if m != nil {
		return m.ExpiryLimit
	}
	return 0
}

func (m *Params) GetMaxScheduledTime() int64 {
	if m != nil {
		return m.MaxScheduledTime
	}
	return 0
}

func init() {
	proto.RegisterType((*Task)(nil), "dysonprotocol.crontask.v1.Task")
	proto.RegisterType((*Params)(nil), "dysonprotocol.crontask.v1.Params")
}

func init() {
	proto.RegisterFile("dysonprotocol/crontask/v1/crontask.proto", fileDescriptor_c2a40f3e0e41e1b8)
}

var fileDescriptor_c2a40f3e0e41e1b8 = []byte{
	// 575 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x41, 0x6f, 0xd3, 0x30,
	0x14, 0x6e, 0xb6, 0xd2, 0xad, 0x6e, 0xc7, 0x86, 0x99, 0x98, 0x37, 0xa4, 0x50, 0x06, 0x42, 0x01,
	0x41, 0xa2, 0x0e, 0x71, 0xe3, 0xb2, 0x22, 0x0d, 0x81, 0x76, 0x98, 0xb2, 0x9d, 0xb8, 0x44, 0x6e,
	0xe2, 0x99, 0xa8, 0x71, 0x5c, 0xf9, 0xb9, 0x55, 0x7b, 0xe4, 0x1f, 0xf0, 0x23, 0x38, 0x70, 0xe4,
	0xc0, 0x8f, 0xd8, 0x71, 0xe2, 0xc4, 0x09, 0xa1, 0xf6, 0xc0, 0xdf, 0x40, 0xb1, 0xd3, 0xac, 0x03,
	0x09, 0x89, 0x4b, 0xe4, 0xf7, 0x7d, 0xdf, 0x7b, 0x79, 0x7e, 0xdf, 0x33, 0xf2, 0x92, 0x29, 0xc8,
	0x7c, 0xa8, 0xa4, 0x96, 0xb1, 0xcc, 0x82, 0x58, 0xc9, 0x5c, 0x53, 0x18, 0x04, 0xe3, 0x6e, 0x75,
	0xf6, 0x0d, 0x8b, 0x77, 0xaf, 0x29, 0xfd, 0x8a, 0x1d, 0x77, 0xf7, 0xb6, 0xb9, 0xe4, 0xd2, 0x30,
	0x41, 0x71, 0xb2, 0x09, 0x7b, 0xbb, 0xb1, 0x04, 0x21, 0x21, 0xb2, 0x84, 0x0d, 0x4a, 0xca, 0xb5,
	0x51, 0xd0, 0xa7, 0xc0, 0x82, 0x71, 0xb7, 0xcf, 0x34, 0xed, 0x06, 0xb1, 0x4c, 0xf3, 0xbf, 0xf8,
	0x7c, 0x50, 0xf1, 0x45, 0x50, 0xf2, 0xb7, 0xa8, 0x48, 0x73, 0x19, 0x98, 0x6f, 0x09, 0xed, 0x94,
	0x29, 0x02, 0x78, 0xd1, 0xbc, 0x00, 0xbe, 0x68, 0x83, 0x4b, 0xc9, 0x33, 0x16, 0x98, 0xa8, 0x3f,
	0x3a, 0x0f, 0x68, 0x3e, 0xb5, 0xd4, 0xfe, 0xa7, 0x3a, 0xaa, 0x9f, 0x51, 0x18, 0xe0, 0x1d, 0xb4,
	0x56, 0xdc, 0x25, 0x4a, 0x13, 0xe2, 0x74, 0x1c, 0xaf, 0x1e, 0x36, 0x8a, 0xf0, 0x4d, 0x82, 0x0f,
	0xd0, 0x5a, 0xac, 0x18, 0xd5, 0x52, 0x91, 0x95, 0x8e, 0xe3, 0x35, 0x7b, 0xe4, 0xdb, 0xd7, 0x67,
	0xdb, 0xe5, 0x5d, 0x0e, 0x93, 0x44, 0x31, 0x80, 0x53, 0xad, 0xd2, 0x9c, 0x87, 0x0b, 0x21, 0x0e,
	0xd0, 0x6d, 0x88, 0xdf, 0xb3, 0x64, 0x94, 0xb1, 0x24, 0xd2, 0xa9, 0x60, 0xa0, 0xa9, 0x18, 0x92,
	0xd5, 0x8e, 0xe3, 0xad, 0x86, 0xb8, 0xa2, 0xce, 0x16, 0x0c, 0x7e, 0x8c, 0xb6, 0xd8, 0x64, 0x98,
	0xaa, 0xe9, 0x92, 0xba, 0x6e, 0xd4, 0x9b, 0x16, 0xbf, 0x92, 0x3e, 0x44, 0x37, 0x4d, 0xa3, 0x9c,
	0x42, 0x94, 0xa5, 0x22, 0xd5, 0xe4, 0x86, 0xe9, 0xb7, 0x5d, 0xa0, 0xaf, 0x29, 0x1c, 0x17, 0x18,
	0x7e, 0xbb, 0xa4, 0x1a, 0xaa, 0x34, 0x66, 0xa4, 0xd1, 0x71, 0xbc, 0xd6, 0xc1, 0xae, 0x5f, 0x76,
	0x5e, 0xcc, 0xdd, 0x2f, 0xe7, 0xea, 0xbf, 0x92, 0x69, 0xde, 0x6b, 0x5e, 0xfc, 0xb8, 0x57, 0xfb,
	0xfc, 0xeb, 0xcb, 0x13, 0xa7, 0xaa, 0x75, 0x52, 0x64, 0xe2, 0x23, 0xd4, 0xae, 0x6a, 0x9d, 0x33,
	0x46, 0xd6, 0xfe, 0xa3, 0x12, 0x2a, 0x2b, 0x1d, 0x31, 0x86, 0x3d, 0x54, 0x17, 0xc0, 0x81, 0xac,
	0x77, 0x56, 0xbd, 0xd6, 0xc1, 0xb6, 0x6f, 0x5d, 0xf1, 0x17, 0xae, 0xf8, 0x87, 0xf9, 0x34, 0x34,
	0x0a, 0xfc, 0x02, 0xb5, 0x04, 0xf0, 0x48, 0x31, 0x18, 0x65, 0x1a, 0x48, 0xf3, 0x1f, 0x09, 0x48,
	0x00, 0x0f, 0xad, 0x0e, 0xdf, 0x41, 0x0d, 0xd0, 0x54, 0x8f, 0x80, 0xa0, 0xc2, 0xa9, 0xb0, 0x8c,
	0xf0, 0x03, 0xb4, 0x61, 0x9c, 0x49, 0x65, 0x6e, 0xe6, 0x4b, 0x5a, 0x66, 0xb4, 0xed, 0x05, 0x58,
	0x0c, 0x17, 0xdf, 0x45, 0x4d, 0xa6, 0x94, 0x54, 0x51, 0x26, 0x39, 0x69, 0x9b, 0xfc, 0x75, 0x03,
	0x1c, 0x4b, 0xbe, 0xff, 0xc1, 0x41, 0x8d, 0x13, 0xaa, 0xa8, 0x00, 0xfc, 0x08, 0x6d, 0xf6, 0x33,
	0x19, 0x2f, 0x1b, 0x60, 0x17, 0x66, 0xc3, 0xc0, 0x95, 0x03, 0xf7, 0x51, 0xbb, 0xb4, 0xd4, 0x8a,
	0x56, 0xcc, 0x3f, 0x5b, 0x16, 0xb3, 0x92, 0xa7, 0x08, 0x0b, 0x3a, 0x89, 0xae, 0xaf, 0x4a, 0xb9,
	0x25, 0x5b, 0x82, 0x4e, 0x4e, 0x97, 0x17, 0xa5, 0xf7, 0xf2, 0x62, 0xe6, 0x3a, 0x97, 0x33, 0xd7,
	0xf9, 0x39, 0x73, 0x9d, 0x8f, 0x73, 0xb7, 0x76, 0x39, 0x77, 0x6b, 0xdf, 0xe7, 0x6e, 0xed, 0xdd,
	0xfe, 0x1f, 0xef, 0x52, 0x8a, 0x60, 0x72, 0xf5, 0x8e, 0xf5, 0x74, 0xc8, 0xa0, 0xdf, 0x30, 0xf4,
	0xf3, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf1, 0xd8, 0x75, 0x4c, 0xee, 0x03, 0x00, 0x00,
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Task) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorLog) > 0 {
		i -= len(m.ErrorLog)
		copy(dAtA[i:], m.ErrorLog)
		i = encodeVarintCrontask(dAtA, i, uint64(len(m.ErrorLog)))
		i--
		dAtA[i] = 0x62
	}
	if m.CreationTime != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.CreationTime))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintCrontask(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MsgResults) > 0 {
		for iNdEx := len(m.MsgResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrontask(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrontask(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.TaskGasFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCrontask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.TaskGasPrice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCrontask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.TaskGasLimit != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.TaskGasLimit))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpiryTimestamp != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.ExpiryTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.ScheduledTimestamp != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.ScheduledTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintCrontask(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskId != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.TaskId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxScheduledTime != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.MaxScheduledTime))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpiryLimit != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.ExpiryLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockGasLimit != 0 {
		i = encodeVarintCrontask(dAtA, i, uint64(m.BlockGasLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrontask(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrontask(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Task) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovCrontask(uint64(m.TaskId))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovCrontask(uint64(l))
	}
	if m.ScheduledTimestamp != 0 {
		n += 1 + sovCrontask(uint64(m.ScheduledTimestamp))
	}
	if m.ExpiryTimestamp != 0 {
		n += 1 + sovCrontask(uint64(m.ExpiryTimestamp))
	}
	if m.TaskGasLimit != 0 {
		n += 1 + sovCrontask(uint64(m.TaskGasLimit))
	}
	l = m.TaskGasPrice.Size()
	n += 1 + l + sovCrontask(uint64(l))
	l = m.TaskGasFee.Size()
	n += 1 + l + sovCrontask(uint64(l))
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovCrontask(uint64(l))
		}
	}
	if len(m.MsgResults) > 0 {
		for _, e := range m.MsgResults {
			l = e.Size()
			n += 1 + l + sovCrontask(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCrontask(uint64(l))
	}
	if m.CreationTime != 0 {
		n += 1 + sovCrontask(uint64(m.CreationTime))
	}
	l = len(m.ErrorLog)
	if l > 0 {
		n += 1 + l + sovCrontask(uint64(l))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockGasLimit != 0 {
		n += 1 + sovCrontask(uint64(m.BlockGasLimit))
	}
	if m.ExpiryLimit != 0 {
		n += 1 + sovCrontask(uint64(m.ExpiryLimit))
	}
	if m.MaxScheduledTime != 0 {
		n += 1 + sovCrontask(uint64(m.MaxScheduledTime))
	}
	return n
}

func sovCrontask(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrontask(x uint64) (n int) {
	return sovCrontask(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrontask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledTimestamp", wireType)
			}
			m.ScheduledTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduledTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTimestamp", wireType)
			}
			m.ExpiryTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskGasLimit", wireType)
			}
			m.TaskGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskGasPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskGasFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskGasFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &any.Any{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgResults = append(m.MsgResults, &any.Any{})
			if err := m.MsgResults[len(m.MsgResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			m.CreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrontask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrontask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrontask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrontask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrontask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGasLimit", wireType)
			}
			m.BlockGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryLimit", wireType)
			}
			m.ExpiryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScheduledTime", wireType)
			}
			m.MaxScheduledTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScheduledTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrontask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrontask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrontask(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrontask
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrontask
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrontask
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrontask
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrontask
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrontask        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrontask          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrontask = fmt.Errorf("proto: unexpected end of group")
)
