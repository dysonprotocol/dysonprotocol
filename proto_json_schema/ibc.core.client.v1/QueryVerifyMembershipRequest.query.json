{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/QueryVerifyMembershipRequest",
    "definitions": {
        "QueryVerifyMembershipRequest": {
            "properties": {
                "client_id": {
                    "type": "string",
                    "description": "client unique identifier."
                },
                "proof": {
                    "type": "string",
                    "description": "the proof to be verified by the client.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "proof_height": {
                    "$ref": "#/definitions/ibc.core.client.v1.Height",
                    "additionalProperties": true,
                    "description": "the height of the commitment root at which the proof is verified."
                },
                "value": {
                    "type": "string",
                    "description": "the value which is proven.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "time_delay": {
                    "type": "string",
                    "description": "optional time delay"
                },
                "block_delay": {
                    "type": "string",
                    "description": "optional block delay"
                },
                "merkle_path": {
                    "$ref": "#/definitions/ibc.core.commitment.v2.MerklePath",
                    "additionalProperties": true,
                    "description": "the commitment key path."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Query Verify Membership Request",
            "description": "QueryVerifyMembershipRequest is the request type for the Query/VerifyMembership RPC method"
        },
        "ibc.core.client.v1.Height": {
            "properties": {
                "revision_number": {
                    "type": "string",
                    "description": "the revision that the client is currently on"
                },
                "revision_height": {
                    "type": "string",
                    "description": "the height within the given revision"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Height",
            "description": "Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset Please note that json tags for generated Go code are overridden to explicitly exclude the omitempty jsontag. This enforces the Go json marshaller to always emit zero values for both revision_number and revision_height."
        },
        "ibc.core.commitment.v2.MerklePath": {
            "properties": {
                "key_path": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "format": "binary",
                    "binaryEncoding": "base64"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Merkle Path",
            "description": "MerklePath is the path used to verify commitment proofs, which can be an arbitrary structured object (defined by a commitment type). ICS-23 verification supports membership proofs for nested merkle trees. The ICS-24 standard provable keys MUST be stored in the lowest level tree with an optional prefix. The IC24 provable tree may then be stored in a higher level tree(s) that hash up to the root hash stored in the consensus state of the client. Each element of the path represents the key of a merkle tree from the root to the leaf. The elements of the path before the final element must be the path to the tree that contains the ICS24 provable store. Thus, it should remain constant for all ICS24 proofs. The final element of the path is the key of the leaf in the ICS24 provable store, Thus IBC core will append the ICS24 path to the final element of the MerklePath stored in the counterparty to create the full path to the leaf for proof verification. Examples: Cosmos SDK: The Cosmos SDK commits to a multi-tree where each store is an IAVL tree and all store hashes are hashed in a simple merkle tree to get the final root hash. Thus, the MerklePath in the counterparty MerklePrefix has the following structure: [\"ibc\", \"\"] The core IBC handler will append the ICS24 path to the final element of the MerklePath like so: [\"ibc\", \"{packetCommitmentPath}\"] which will then be used for final verification. Ethereum: The Ethereum client commits to a single Patricia merkle trie. The ICS24 provable store is managed by the smart contract state. Each smart contract has a specific prefix reserved within the global trie. Thus the MerklePath in the counterparty is the prefix to the smart contract state in the global trie. Since there is only one tree in the commitment structure of ethereum the MerklePath in the counterparty MerklePrefix has the following structure: [\"IBCCoreContractAddressStoragePrefix\"] The core IBC handler will append the ICS24 path to the final element of the MerklePath like so: [\"IBCCoreContractAddressStoragePrefix{packetCommitmentPath}\"] which will then be used for final verification. Thus the MerklePath in the counterparty MerklePrefix is the nested key path from the root hash of the consensus state down to the ICS24 provable store. The IBC handler retrieves the counterparty key path to the ICS24 provable store from the MerklePath and appends the ICS24 path to get the final key path to the value being verified by the client against the root hash in the client's consensus state."
        }
    }
}