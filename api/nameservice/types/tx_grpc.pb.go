// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: dysonprotocol/nameservice/v1/tx.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Msg_Commit_FullMethodName                  = "/dysonprotocol.nameservice.v1.Msg/Commit"
	Msg_Reveal_FullMethodName                  = "/dysonprotocol.nameservice.v1.Msg/Reveal"
	Msg_SetValuation_FullMethodName            = "/dysonprotocol.nameservice.v1.Msg/SetValuation"
	Msg_Renew_FullMethodName                   = "/dysonprotocol.nameservice.v1.Msg/Renew"
	Msg_PlaceBid_FullMethodName                = "/dysonprotocol.nameservice.v1.Msg/PlaceBid"
	Msg_AcceptBid_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/AcceptBid"
	Msg_RejectBid_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/RejectBid"
	Msg_ClaimBid_FullMethodName                = "/dysonprotocol.nameservice.v1.Msg/ClaimBid"
	Msg_SetDestination_FullMethodName          = "/dysonprotocol.nameservice.v1.Msg/SetDestination"
	Msg_SetNFTMetadata_FullMethodName          = "/dysonprotocol.nameservice.v1.Msg/SetNFTMetadata"
	Msg_SetNFTClassExtraData_FullMethodName    = "/dysonprotocol.nameservice.v1.Msg/SetNFTClassExtraData"
	Msg_SetNFTClassAlwaysListed_FullMethodName = "/dysonprotocol.nameservice.v1.Msg/SetNFTClassAlwaysListed"
	Msg_SetNFTClassAnnualPct_FullMethodName    = "/dysonprotocol.nameservice.v1.Msg/SetNFTClassAnnualPct"
	Msg_SetListed_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/SetListed"
	Msg_UpdateParams_FullMethodName            = "/dysonprotocol.nameservice.v1.Msg/UpdateParams"
	Msg_MintCoins_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/MintCoins"
	Msg_BurnCoins_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/BurnCoins"
	Msg_SetDenomMetadata_FullMethodName        = "/dysonprotocol.nameservice.v1.Msg/SetDenomMetadata"
	Msg_SaveClass_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/SaveClass"
	Msg_MintNFT_FullMethodName                 = "/dysonprotocol.nameservice.v1.Msg/MintNFT"
	Msg_BurnNFT_FullMethodName                 = "/dysonprotocol.nameservice.v1.Msg/BurnNFT"
	Msg_MoveCoins_FullMethodName               = "/dysonprotocol.nameservice.v1.Msg/MoveCoins"
	Msg_MoveNft_FullMethodName                 = "/dysonprotocol.nameservice.v1.Msg/MoveNft"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Msg defines the Msg service.
type MsgClient interface {
	Commit(ctx context.Context, in *MsgCommit, opts ...grpc.CallOption) (*MsgCommitResponse, error)
	Reveal(ctx context.Context, in *MsgReveal, opts ...grpc.CallOption) (*MsgRevealResponse, error)
	SetValuation(ctx context.Context, in *MsgSetValuation, opts ...grpc.CallOption) (*MsgSetValuationResponse, error)
	Renew(ctx context.Context, in *MsgRenew, opts ...grpc.CallOption) (*MsgRenewResponse, error)
	PlaceBid(ctx context.Context, in *MsgPlaceBid, opts ...grpc.CallOption) (*MsgPlaceBidResponse, error)
	AcceptBid(ctx context.Context, in *MsgAcceptBid, opts ...grpc.CallOption) (*MsgAcceptBidResponse, error)
	RejectBid(ctx context.Context, in *MsgRejectBid, opts ...grpc.CallOption) (*MsgRejectBidResponse, error)
	ClaimBid(ctx context.Context, in *MsgClaimBid, opts ...grpc.CallOption) (*MsgClaimBidResponse, error)
	SetDestination(ctx context.Context, in *MsgSetDestination, opts ...grpc.CallOption) (*MsgSetDestinationResponse, error)
	SetNFTMetadata(ctx context.Context, in *MsgSetNFTMetadata, opts ...grpc.CallOption) (*MsgSetNFTMetadataResponse, error)
	SetNFTClassExtraData(ctx context.Context, in *MsgSetNFTClassExtraData, opts ...grpc.CallOption) (*MsgSetNFTClassExtraDataResponse, error)
	// SetNFTClassAlwaysListed sets the always_listed flag for an NFT class
	SetNFTClassAlwaysListed(ctx context.Context, in *MsgSetNFTClassAlwaysListed, opts ...grpc.CallOption) (*MsgSetNFTClassAlwaysListedResponse, error)
	// SetNFTClassAnnualPct sets the annual percentage rate for an NFT class
	SetNFTClassAnnualPct(ctx context.Context, in *MsgSetNFTClassAnnualPct, opts ...grpc.CallOption) (*MsgSetNFTClassAnnualPctResponse, error)
	// SetListed sets the listed status for a specific NFT
	SetListed(ctx context.Context, in *MsgSetListed, opts ...grpc.CallOption) (*MsgSetListedResponse, error)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	MintCoins(ctx context.Context, in *MsgMintCoins, opts ...grpc.CallOption) (*MsgMintCoinsResponse, error)
	BurnCoins(ctx context.Context, in *MsgBurnCoins, opts ...grpc.CallOption) (*MsgBurnCoinsResponse, error)
	SetDenomMetadata(ctx context.Context, in *MsgSetDenomMetadata, opts ...grpc.CallOption) (*MsgSetDenomMetadataResponse, error)
	SaveClass(ctx context.Context, in *MsgSaveClass, opts ...grpc.CallOption) (*MsgSaveClassResponse, error)
	MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error)
	BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error)
	MoveCoins(ctx context.Context, in *MsgMoveCoins, opts ...grpc.CallOption) (*MsgMoveCoinsResponse, error)
	MoveNft(ctx context.Context, in *MsgMoveNft, opts ...grpc.CallOption) (*MsgMoveNftResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Commit(ctx context.Context, in *MsgCommit, opts ...grpc.CallOption) (*MsgCommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCommitResponse)
	err := c.cc.Invoke(ctx, Msg_Commit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Reveal(ctx context.Context, in *MsgReveal, opts ...grpc.CallOption) (*MsgRevealResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRevealResponse)
	err := c.cc.Invoke(ctx, Msg_Reveal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetValuation(ctx context.Context, in *MsgSetValuation, opts ...grpc.CallOption) (*MsgSetValuationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetValuationResponse)
	err := c.cc.Invoke(ctx, Msg_SetValuation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Renew(ctx context.Context, in *MsgRenew, opts ...grpc.CallOption) (*MsgRenewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRenewResponse)
	err := c.cc.Invoke(ctx, Msg_Renew_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PlaceBid(ctx context.Context, in *MsgPlaceBid, opts ...grpc.CallOption) (*MsgPlaceBidResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgPlaceBidResponse)
	err := c.cc.Invoke(ctx, Msg_PlaceBid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AcceptBid(ctx context.Context, in *MsgAcceptBid, opts ...grpc.CallOption) (*MsgAcceptBidResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAcceptBidResponse)
	err := c.cc.Invoke(ctx, Msg_AcceptBid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RejectBid(ctx context.Context, in *MsgRejectBid, opts ...grpc.CallOption) (*MsgRejectBidResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRejectBidResponse)
	err := c.cc.Invoke(ctx, Msg_RejectBid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimBid(ctx context.Context, in *MsgClaimBid, opts ...grpc.CallOption) (*MsgClaimBidResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgClaimBidResponse)
	err := c.cc.Invoke(ctx, Msg_ClaimBid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDestination(ctx context.Context, in *MsgSetDestination, opts ...grpc.CallOption) (*MsgSetDestinationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetDestinationResponse)
	err := c.cc.Invoke(ctx, Msg_SetDestination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTMetadata(ctx context.Context, in *MsgSetNFTMetadata, opts ...grpc.CallOption) (*MsgSetNFTMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetNFTMetadataResponse)
	err := c.cc.Invoke(ctx, Msg_SetNFTMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTClassExtraData(ctx context.Context, in *MsgSetNFTClassExtraData, opts ...grpc.CallOption) (*MsgSetNFTClassExtraDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetNFTClassExtraDataResponse)
	err := c.cc.Invoke(ctx, Msg_SetNFTClassExtraData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTClassAlwaysListed(ctx context.Context, in *MsgSetNFTClassAlwaysListed, opts ...grpc.CallOption) (*MsgSetNFTClassAlwaysListedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetNFTClassAlwaysListedResponse)
	err := c.cc.Invoke(ctx, Msg_SetNFTClassAlwaysListed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNFTClassAnnualPct(ctx context.Context, in *MsgSetNFTClassAnnualPct, opts ...grpc.CallOption) (*MsgSetNFTClassAnnualPctResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetNFTClassAnnualPctResponse)
	err := c.cc.Invoke(ctx, Msg_SetNFTClassAnnualPct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetListed(ctx context.Context, in *MsgSetListed, opts ...grpc.CallOption) (*MsgSetListedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetListedResponse)
	err := c.cc.Invoke(ctx, Msg_SetListed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintCoins(ctx context.Context, in *MsgMintCoins, opts ...grpc.CallOption) (*MsgMintCoinsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgMintCoinsResponse)
	err := c.cc.Invoke(ctx, Msg_MintCoins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnCoins(ctx context.Context, in *MsgBurnCoins, opts ...grpc.CallOption) (*MsgBurnCoinsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBurnCoinsResponse)
	err := c.cc.Invoke(ctx, Msg_BurnCoins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDenomMetadata(ctx context.Context, in *MsgSetDenomMetadata, opts ...grpc.CallOption) (*MsgSetDenomMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSetDenomMetadataResponse)
	err := c.cc.Invoke(ctx, Msg_SetDenomMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SaveClass(ctx context.Context, in *MsgSaveClass, opts ...grpc.CallOption) (*MsgSaveClassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSaveClassResponse)
	err := c.cc.Invoke(ctx, Msg_SaveClass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgMintNFTResponse)
	err := c.cc.Invoke(ctx, Msg_MintNFT_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBurnNFTResponse)
	err := c.cc.Invoke(ctx, Msg_BurnNFT_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MoveCoins(ctx context.Context, in *MsgMoveCoins, opts ...grpc.CallOption) (*MsgMoveCoinsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgMoveCoinsResponse)
	err := c.cc.Invoke(ctx, Msg_MoveCoins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MoveNft(ctx context.Context, in *MsgMoveNft, opts ...grpc.CallOption) (*MsgMoveNftResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgMoveNftResponse)
	err := c.cc.Invoke(ctx, Msg_MoveNft_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility.
//
// Msg defines the Msg service.
type MsgServer interface {
	Commit(context.Context, *MsgCommit) (*MsgCommitResponse, error)
	Reveal(context.Context, *MsgReveal) (*MsgRevealResponse, error)
	SetValuation(context.Context, *MsgSetValuation) (*MsgSetValuationResponse, error)
	Renew(context.Context, *MsgRenew) (*MsgRenewResponse, error)
	PlaceBid(context.Context, *MsgPlaceBid) (*MsgPlaceBidResponse, error)
	AcceptBid(context.Context, *MsgAcceptBid) (*MsgAcceptBidResponse, error)
	RejectBid(context.Context, *MsgRejectBid) (*MsgRejectBidResponse, error)
	ClaimBid(context.Context, *MsgClaimBid) (*MsgClaimBidResponse, error)
	SetDestination(context.Context, *MsgSetDestination) (*MsgSetDestinationResponse, error)
	SetNFTMetadata(context.Context, *MsgSetNFTMetadata) (*MsgSetNFTMetadataResponse, error)
	SetNFTClassExtraData(context.Context, *MsgSetNFTClassExtraData) (*MsgSetNFTClassExtraDataResponse, error)
	// SetNFTClassAlwaysListed sets the always_listed flag for an NFT class
	SetNFTClassAlwaysListed(context.Context, *MsgSetNFTClassAlwaysListed) (*MsgSetNFTClassAlwaysListedResponse, error)
	// SetNFTClassAnnualPct sets the annual percentage rate for an NFT class
	SetNFTClassAnnualPct(context.Context, *MsgSetNFTClassAnnualPct) (*MsgSetNFTClassAnnualPctResponse, error)
	// SetListed sets the listed status for a specific NFT
	SetListed(context.Context, *MsgSetListed) (*MsgSetListedResponse, error)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	MintCoins(context.Context, *MsgMintCoins) (*MsgMintCoinsResponse, error)
	BurnCoins(context.Context, *MsgBurnCoins) (*MsgBurnCoinsResponse, error)
	SetDenomMetadata(context.Context, *MsgSetDenomMetadata) (*MsgSetDenomMetadataResponse, error)
	SaveClass(context.Context, *MsgSaveClass) (*MsgSaveClassResponse, error)
	MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error)
	BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error)
	MoveCoins(context.Context, *MsgMoveCoins) (*MsgMoveCoinsResponse, error)
	MoveNft(context.Context, *MsgMoveNft) (*MsgMoveNftResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMsgServer struct{}

func (UnimplementedMsgServer) Commit(context.Context, *MsgCommit) (*MsgCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedMsgServer) Reveal(context.Context, *MsgReveal) (*MsgRevealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reveal not implemented")
}
func (UnimplementedMsgServer) SetValuation(context.Context, *MsgSetValuation) (*MsgSetValuationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetValuation not implemented")
}
func (UnimplementedMsgServer) Renew(context.Context, *MsgRenew) (*MsgRenewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Renew not implemented")
}
func (UnimplementedMsgServer) PlaceBid(context.Context, *MsgPlaceBid) (*MsgPlaceBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceBid not implemented")
}
func (UnimplementedMsgServer) AcceptBid(context.Context, *MsgAcceptBid) (*MsgAcceptBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptBid not implemented")
}
func (UnimplementedMsgServer) RejectBid(context.Context, *MsgRejectBid) (*MsgRejectBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectBid not implemented")
}
func (UnimplementedMsgServer) ClaimBid(context.Context, *MsgClaimBid) (*MsgClaimBidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimBid not implemented")
}
func (UnimplementedMsgServer) SetDestination(context.Context, *MsgSetDestination) (*MsgSetDestinationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDestination not implemented")
}
func (UnimplementedMsgServer) SetNFTMetadata(context.Context, *MsgSetNFTMetadata) (*MsgSetNFTMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTMetadata not implemented")
}
func (UnimplementedMsgServer) SetNFTClassExtraData(context.Context, *MsgSetNFTClassExtraData) (*MsgSetNFTClassExtraDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTClassExtraData not implemented")
}
func (UnimplementedMsgServer) SetNFTClassAlwaysListed(context.Context, *MsgSetNFTClassAlwaysListed) (*MsgSetNFTClassAlwaysListedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTClassAlwaysListed not implemented")
}
func (UnimplementedMsgServer) SetNFTClassAnnualPct(context.Context, *MsgSetNFTClassAnnualPct) (*MsgSetNFTClassAnnualPctResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNFTClassAnnualPct not implemented")
}
func (UnimplementedMsgServer) SetListed(context.Context, *MsgSetListed) (*MsgSetListedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetListed not implemented")
}
func (UnimplementedMsgServer) UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (UnimplementedMsgServer) MintCoins(context.Context, *MsgMintCoins) (*MsgMintCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintCoins not implemented")
}
func (UnimplementedMsgServer) BurnCoins(context.Context, *MsgBurnCoins) (*MsgBurnCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnCoins not implemented")
}
func (UnimplementedMsgServer) SetDenomMetadata(context.Context, *MsgSetDenomMetadata) (*MsgSetDenomMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDenomMetadata not implemented")
}
func (UnimplementedMsgServer) SaveClass(context.Context, *MsgSaveClass) (*MsgSaveClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveClass not implemented")
}
func (UnimplementedMsgServer) MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (UnimplementedMsgServer) BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFT not implemented")
}
func (UnimplementedMsgServer) MoveCoins(context.Context, *MsgMoveCoins) (*MsgMoveCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveCoins not implemented")
}
func (UnimplementedMsgServer) MoveNft(context.Context, *MsgMoveNft) (*MsgMoveNftResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveNft not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}
func (UnimplementedMsgServer) testEmbeddedByValue()             {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	// If the following call pancis, it indicates UnimplementedMsgServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Commit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Commit(ctx, req.(*MsgCommit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Reveal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReveal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Reveal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Reveal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Reveal(ctx, req.(*MsgReveal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetValuation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetValuation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetValuation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetValuation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetValuation(ctx, req.(*MsgSetValuation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Renew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRenew)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Renew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Renew_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Renew(ctx, req.(*MsgRenew))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PlaceBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPlaceBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PlaceBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_PlaceBid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PlaceBid(ctx, req.(*MsgPlaceBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AcceptBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAcceptBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AcceptBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AcceptBid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AcceptBid(ctx, req.(*MsgAcceptBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RejectBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRejectBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RejectBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RejectBid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RejectBid(ctx, req.(*MsgRejectBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimBid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ClaimBid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimBid(ctx, req.(*MsgClaimBid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDestination(ctx, req.(*MsgSetDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNFTMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTMetadata(ctx, req.(*MsgSetNFTMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTClassExtraData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTClassExtraData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTClassExtraData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNFTClassExtraData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTClassExtraData(ctx, req.(*MsgSetNFTClassExtraData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTClassAlwaysListed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTClassAlwaysListed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTClassAlwaysListed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNFTClassAlwaysListed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTClassAlwaysListed(ctx, req.(*MsgSetNFTClassAlwaysListed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNFTClassAnnualPct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNFTClassAnnualPct)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNFTClassAnnualPct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNFTClassAnnualPct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNFTClassAnnualPct(ctx, req.(*MsgSetNFTClassAnnualPct))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetListed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetListed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetListed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetListed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetListed(ctx, req.(*MsgSetListed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MintCoins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintCoins(ctx, req.(*MsgMintCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnCoins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnCoins(ctx, req.(*MsgBurnCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDenomMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDenomMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDenomMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetDenomMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDenomMetadata(ctx, req.(*MsgSetDenomMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SaveClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSaveClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SaveClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SaveClass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SaveClass(ctx, req.(*MsgSaveClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MintNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNFT(ctx, req.(*MsgMintNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFT(ctx, req.(*MsgBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MoveCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMoveCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MoveCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MoveCoins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MoveCoins(ctx, req.(*MsgMoveCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MoveNft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMoveNft)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MoveNft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MoveNft_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MoveNft(ctx, req.(*MsgMoveNft))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dysonprotocol.nameservice.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Commit",
			Handler:    _Msg_Commit_Handler,
		},
		{
			MethodName: "Reveal",
			Handler:    _Msg_Reveal_Handler,
		},
		{
			MethodName: "SetValuation",
			Handler:    _Msg_SetValuation_Handler,
		},
		{
			MethodName: "Renew",
			Handler:    _Msg_Renew_Handler,
		},
		{
			MethodName: "PlaceBid",
			Handler:    _Msg_PlaceBid_Handler,
		},
		{
			MethodName: "AcceptBid",
			Handler:    _Msg_AcceptBid_Handler,
		},
		{
			MethodName: "RejectBid",
			Handler:    _Msg_RejectBid_Handler,
		},
		{
			MethodName: "ClaimBid",
			Handler:    _Msg_ClaimBid_Handler,
		},
		{
			MethodName: "SetDestination",
			Handler:    _Msg_SetDestination_Handler,
		},
		{
			MethodName: "SetNFTMetadata",
			Handler:    _Msg_SetNFTMetadata_Handler,
		},
		{
			MethodName: "SetNFTClassExtraData",
			Handler:    _Msg_SetNFTClassExtraData_Handler,
		},
		{
			MethodName: "SetNFTClassAlwaysListed",
			Handler:    _Msg_SetNFTClassAlwaysListed_Handler,
		},
		{
			MethodName: "SetNFTClassAnnualPct",
			Handler:    _Msg_SetNFTClassAnnualPct_Handler,
		},
		{
			MethodName: "SetListed",
			Handler:    _Msg_SetListed_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "MintCoins",
			Handler:    _Msg_MintCoins_Handler,
		},
		{
			MethodName: "BurnCoins",
			Handler:    _Msg_BurnCoins_Handler,
		},
		{
			MethodName: "SetDenomMetadata",
			Handler:    _Msg_SetDenomMetadata_Handler,
		},
		{
			MethodName: "SaveClass",
			Handler:    _Msg_SaveClass_Handler,
		},
		{
			MethodName: "MintNFT",
			Handler:    _Msg_MintNFT_Handler,
		},
		{
			MethodName: "BurnNFT",
			Handler:    _Msg_BurnNFT_Handler,
		},
		{
			MethodName: "MoveCoins",
			Handler:    _Msg_MoveCoins_Handler,
		},
		{
			MethodName: "MoveNft",
			Handler:    _Msg_MoveNft_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dysonprotocol/nameservice/v1/tx.proto",
}
